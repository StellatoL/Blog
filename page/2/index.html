<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="老大，欢迎回来喵~">
<meta property="og:type" content="website">
<meta property="og:title" content="Stellato的星空">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Stellato的星空">
<meta property="og:description" content="老大，欢迎回来喵~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="St_w">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Stellato的星空</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stellato的星空</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%A4%A7%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%A4%A7%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">视频编码大作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:16:07" itemprop="dateModified" datetime="2025-05-31T13:16:07+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E7%89%A9/" itemprop="url" rel="index"><span itemprop="name">杂物</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好的，这是一个《视频编码标准及其算法原理》的大作业。我会针对你提出的每一项任务要求，提供详细的步骤、原理、公式，并指出在MATLAB中可能用到的函数或方法。</p>
<p><strong>请注意：</strong> 由于我无法直接访问你的图像帧F1和F2，也无法执行MATLAB代码，因此我将提供的是一个框架和原理性的指导。你需要准备好你的图像数据，并根据这些指导在MATLAB中实现具体的代码。</p>
<hr>
<p><strong>1. 任务要求：使用matlab完成所有流程</strong></p>
<p>这表示所有后续步骤的计算、变换、编码等都需要你通过编写MATLAB脚本来实现。</p>
<hr>
<p><strong>2. 对帧F1进行JPEG编码（帧内编码）</strong> 利用matlab实现JPEG的编码和解码重建第一帧F1’，并计算重建图像帧和原始帧F1之间的峰值信噪比PSNR。</p>
<p><strong>JPEG编码流程概述：</strong></p>
<ol>
<li><strong>颜色空间转换（可选）：</strong> 如果是彩色图像，通常从RGB转换到YCbCr。对亮度(Y)和色度(Cb, Cr)分量分别处理。为了简化，我们假设F1是灰度图，或者我们只处理亮度分量。</li>
<li><strong>分块：</strong> 将图像分成8x8的像素块。</li>
<li><strong>离散余弦变换 (DCT)：</strong> 对每个8x8块进行2D-DCT。</li>
<li><strong>量化：</strong> 对DCT系数进行量化，使用标准的量化表。</li>
<li><strong>Zigzag扫描：</strong> 将量化后的2D系数矩阵转换为1D序列。</li>
<li><strong>熵编码：</strong><ul>
<li><strong>DC系数编码：</strong> 对DC系数（每个块的第一个系数，代表平均亮度）进行差分脉冲编码调制 (DPCM)，然后对差值进行熵编码（通常是霍夫曼编码）。</li>
<li><strong>AC系数编码：</strong> 对AC系数（块内其余63个系数）进行游程编码 (RLE)，然后对(run, level)对进行熵编码（通常是霍夫曼编码）。</li>
</ul>
</li>
<li><strong>码流组合：</strong> 将编码后的数据组合成最终的JPEG码流。</li>
</ol>
<p><strong>JPEG解码流程概述：</strong></p>
<ol>
<li><strong>熵解码：</strong> 解码DC和AC系数。</li>
<li><strong>反Zigzag扫描：</strong> 将1D序列恢复成8x8的量化系数矩阵。</li>
<li><strong>反量化：</strong> 对量化系数进行反量化。</li>
<li><strong>反离散余弦变换 (IDCT)：</strong> 对每个块进行2D-IDCT。</li>
<li><strong>图像重建：</strong> 将处理后的8x8块拼接成重建图像。</li>
<li><strong>颜色空间反转换（可选）：</strong> 如果初始进行了转换，则从YCbCr转回RGB。</li>
</ol>
<p><strong>MATLAB 实现步骤 (以灰度图为例):</strong></p>
<ul>
<li><p><strong>读取图像F1：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F1 = imread(&#x27;your_frame_F1.png&#x27;); % 假设是png格式，替换为你的文件名</span><br><span class="line">if size(F1, 3) == 3</span><br><span class="line">    F1_gray = rgb2gray(F1); % 如果是彩色图，转为灰度图</span><br><span class="line">else</span><br><span class="line">    F1_gray = F1;</span><br><span class="line">end</span><br><span class="line">F1_double = double(F1_gray); % 转换为double类型方便计算</span><br><span class="line">[rows, cols] = size(F1_double);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JPEG编码 (简化版，主要关注DCT、量化、反量化、IDCT):</strong></p>
<ul>
<li><p><strong>定义8x8块处理函数 (编码):</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% 标准亮度量化表 (来自JPEG K.1)</span><br><span class="line">Q_lum = [16 11 10 16 24 40 51 61;</span><br><span class="line">         12 12 14 19 26 58 60 55;</span><br><span class="line">         14 13 16 24 40 57 69 56;</span><br><span class="line">         14 17 22 29 51 87 80 62;</span><br><span class="line">         18 22 37 56 68 109 103 77;</span><br><span class="line">         24 35 55 64 81 104 113 92;</span><br><span class="line">         49 64 78 87 103 121 120 101;</span><br><span class="line">         72 92 95 98 112 100 103 99];</span><br><span class="line"></span><br><span class="line">dct_func = @(block_struct) dct2(block_struct.data - 128); % DCT，减128使像素值中心化</span><br><span class="line">quant_func = @(block_struct) round(block_struct.data ./ Q_lum); % 量化</span><br><span class="line"></span><br><span class="line">% 对F1_double进行分块DCT和量化</span><br><span class="line">F1_dct_quant = blockproc(F1_double, [8 8], dct_func);</span><br><span class="line">F1_quantized = blockproc(F1_dct_quant, [8 8], quant_func);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JPEG解码 (简化版):</strong></p>
<ul>
<li><strong>定义8x8块处理函数 (解码):</strong></li>
</ul>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dequant_func = @(block_struct) block_struct.data .* Q_lum; % 反量化</span><br><span class="line">idct_func = @(block_struct) idct2(block_struct.data) + 128; % IDCT，加128恢复</span><br><span class="line"></span><br><span class="line">% 对量化系数进行反量化和IDCT</span><br><span class="line">F1_dequant = blockproc(F1_quantized, [8 8], dequant_func);</span><br><span class="line">F1_reconstructed_double = blockproc(F1_dequant, [8 8], idct_func);</span><br><span class="line">F1_prime = uint8(F1_reconstructed_double); % 转回uint8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong> 上述简化版省略了熵编码部分，因为完整的熵编码比较复杂。对于作业，你可能需要更详细地实现Zigzag扫描和基于霍夫曼表的编码，或者根据老师要求明确是否需要完整熵编码。</p>
</li>
</ul>
</li>
<li><p><strong>计算PSNR：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mse = mean((F1_double(:) - F1_reconstructed_double(:)).^2);</span><br><span class="line">if mse == 0</span><br><span class="line">    psnr_val = Inf;</span><br><span class="line">else</span><br><span class="line">    max_pixel_val = 255; % 假设8位图像</span><br><span class="line">    psnr_val = 10 * log10(max_pixel_val^2 / mse);</span><br><span class="line">end</span><br><span class="line">fprintf(&#x27;PSNR between F1 and F1_prime: %.2f dB\n&#x27;, psnr_val);</span><br><span class="line"></span><br><span class="line">% 显示图像 (可选)</span><br><span class="line">% figure;</span><br><span class="line">% subplot(1,2,1); imshow(F1_gray); title(&#x27;Original F1&#x27;);</span><br><span class="line">% subplot(1,2,2); imshow(F1_prime); title(&#x27;Reconstructed F1&#x27;&#x27;&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>3. 从F1中任选一个8*8的块B1，给出以下详细过程</strong></p>
<p>假设你已经从<code>F1_double</code>中选择了一个8x8的块 <code>B1</code>。</p>
<p>Matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 假设你选择的是F1左上角的第一个8x8块</span><br><span class="line">B1 = F1_double(1:8, 1:8);</span><br></pre></td></tr></table></figure>

<p><strong>3.1 给出该块的8*8矩阵形式：</strong></p>
<p>Matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;3.1 Block B1 (8x8 matrix):&#x27;);</span><br><span class="line">disp(B1);</span><br></pre></td></tr></table></figure>

<p>这里会直接打印出你选定的<code>B1</code>矩阵。</p>
<p><strong>3.2 对块B1进行二维DCT变换，可以借助matlab计算得到。给出变换公式和变换系数块：</strong></p>
<ul>
<li><p><strong>二维DCT变换公式：</strong> 对于一个 N×N 的块 f(x,y)，其2D-DCT系数 F(u,v) 计算如下： F(u,v)&#x3D;C(u)C(v)x&#x3D;0∑N−1​y&#x3D;0∑N−1​f(x,y)cos[2N(2x+1)uπ​]cos[2N(2y+1)vπ​] 其中 u,v&#x3D;0,1,…,N−1，且 C(k)&#x3D;{1&#x2F;N![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
  c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
  c340,-704.7,510.7,-1060.3,512,-1067
  l0 -0
  c4.7,-7.3,11,-11,19,-11
  H40000v40H1012.3
  s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
  c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
  s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
  c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
  M1001 80h400000v40h-400000z"></path></svg>)​2&#x2F;N![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
  c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
  c340,-704.7,510.7,-1060.3,512,-1067
  l0 -0
  c4.7,-7.3,11,-11,19,-11
  H40000v40H1012.3
  s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
  c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
  s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
  c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
  M1001 80h400000v40h-400000z"></path></svg>)​​if k&#x3D;0if k&gt;0​ 对于JPEG，通常先将像素值 f(x,y) 减去 2P−1 (例如，对于8位图像，P&#x3D;8，减去128)。</p>
</li>
<li><p><strong>MATLAB计算：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B1_centered = B1 - 128; % 中心化</span><br><span class="line">B1_dct = dct2(B1_centered);</span><br><span class="line"></span><br><span class="line">disp(&#x27;3.2 DCT Transform Coefficients for B1:&#x27;);</span><br><span class="line">disp(B1_dct);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.3 对变换系数块进行量化</strong> 从jpeg标准文档Table K.1 – Luminance quantization table获取亮度分量的量化矩阵。给出量化过程的公式及量化后的系数矩阵：</p>
<ul>
<li><p><strong>亮度分量量化矩阵 (Table K.1)：</strong> (已在上面给出)</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q_lum = [16 11 10 16 24 40 51 61;</span><br><span class="line">         12 12 14 19 26 58 60 55;</span><br><span class="line">         14 13 16 24 40 57 69 56;</span><br><span class="line">         14 17 22 29 51 87 80 62;</span><br><span class="line">         18 22 37 56 68 109 103 77;</span><br><span class="line">         24 35 55 64 81 104 113 92;</span><br><span class="line">         49 64 78 87 103 121 120 101;</span><br><span class="line">         72 92 95 98 112 100 103 99];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>量化过程公式：</strong> 对于DCT系数矩阵 F(u,v) 和量化矩阵 Q(u,v)，量化后的系数 Fq​(u,v) 为： Fq​(u,v)&#x3D;round(Q(u,v)F(u,v)​)</p>
</li>
<li><p><strong>MATLAB计算：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B1_quantized = round(B1_dct ./ Q_lum);</span><br><span class="line"></span><br><span class="line">disp(&#x27;3.3 Quantized DCT Coefficients for B1:&#x27;);</span><br><span class="line">disp(B1_quantized);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.4 对量化系数矩阵进行Z形扫描，得到一维序列:</strong></p>
<ul>
<li><p><strong>Z形扫描顺序：</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0  1  5  6 14 15 27 28</span><br><span class="line">2  4  7 13 16 26 29 42</span><br><span class="line">3  8 12 17 25 30 41 43</span><br><span class="line">9 11 18 24 31 40 44 53</span><br><span class="line">10 19 23 32 39 45 52 54</span><br><span class="line">20 22 33 38 46 51 55 60</span><br><span class="line">21 34 37 47 50 56 59 61</span><br><span class="line">35 36 48 49 57 58 62 63</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MATLAB实现 (需要一个辅助函数)：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">% Zigzag scan order for 8x8 block</span><br><span class="line">zigzag_order = [</span><br><span class="line">     0  1  5  6 14 15 27 28</span><br><span class="line">     2  4  7 13 16 26 29 42</span><br><span class="line">     3  8 12 17 25 30 41 43</span><br><span class="line">     9 11 18 24 31 40 44 53</span><br><span class="line">    10 19 23 32 39 45 52 54</span><br><span class="line">    20 22 33 38 46 51 55 60</span><br><span class="line">    21 34 37 47 50 56 59 61</span><br><span class="line">    35 36 48 49 57 58 62 63</span><br><span class="line">] + 1; % MATLAB is 1-indexed</span><br><span class="line"></span><br><span class="line">B1_zigzag_scanned = zeros(1, 64);</span><br><span class="line">temp_B1_quantized = B1_quantized&#x27;; % Transpose for column-major zigzag_order scan</span><br><span class="line">for i = 1:64</span><br><span class="line">    B1_zigzag_scanned(i) = temp_B1_quantized(zigzag_order(i));</span><br><span class="line">end</span><br><span class="line">% A more robust way to implement zigzag:</span><br><span class="line">% (You can find many zigzag scan functions for MATLAB online)</span><br><span class="line">% For example:</span><br><span class="line">% function output = zigzag(input)</span><br><span class="line">%     [m, n] = size(input);</span><br><span class="line">%     output = zeros(1, m*n);</span><br><span class="line">%     count = 1;</span><br><span class="line">%     for s = 1:(m+n-1)</span><br><span class="line">%         if mod(s, 2) == 1 % Odd sum: up-right</span><br><span class="line">%             for i = max(1, s-n+1):min(s, m)</span><br><span class="line">%                 j = s - i + 1;</span><br><span class="line">%                 output(count) = input(i, j);</span><br><span class="line">%                 count = count + 1;</span><br><span class="line">%             end</span><br><span class="line">%         else % Even sum: down-left</span><br><span class="line">%             for j = max(1, s-m+1):min(s, n)</span><br><span class="line">%                 i = s - j + 1;</span><br><span class="line">%                 output(count) = input(i, j);</span><br><span class="line">%                 count = count + 1;</span><br><span class="line">%             end</span><br><span class="line">%         end</span><br><span class="line">%     end</span><br><span class="line">% end</span><br><span class="line">% B1_zigzag_scanned = zigzag(B1_quantized);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">disp(&#x27;3.4 Zigzag Scanned 1D Sequence:&#x27;);</span><br><span class="line">disp(B1_zigzag_scanned);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.5 对一维序列进行熵编码，包括给出中间符号1和中间符号2，最后给出该块的码流：</strong> （可能需要用到JPEG标准文档…Table K.3 – Table for luminance DC coefficient differences，Table K.5 – Table for luminance AC coefficients。）</p>
<p>这部分是JPEG编码中最复杂的部分之一，涉及到差分编码、游程编码和霍夫曼编码。 你需要JPEG标准文档中定义的霍夫曼表（K.3, K.4, K.5, K.6）。通常这些表是固定的，或者在JPEG文件头中指定。</p>
<ul>
<li><p><strong>DC系数编码：</strong></p>
<ol>
<li><strong>差分编码 (DPCM):</strong> 第一个块的DC系数直接编码。后续块的DC系数是当前块DC与前一个块DC的差值 (DIFFERENCE &#x3D; DC_current - DC_previous)。 <code>DC_coeff = B1_zigzag_scanned(1);</code> <code>DIFFERENCE = DC_coeff - Previous_DC;</code> (假设<code>Previous_DC</code>是前一个块的DC，对第一个块，<code>Previous_DC = 0</code>)</li>
<li><strong>确定类别 (Category&#x2F;SSSS):</strong> 根据DIFFERENCE的值，查Table K.3（亮度DC系数差值表）确定其类别 (SSSS)。</li>
<li><strong>确定幅值 (Magnitude&#x2F;ZZZZ…):</strong> 对于非零DIFFERENCE，其二进制表示（如果为负，则为其绝对值的反码）是幅值。</li>
<li><strong>霍夫曼编码：</strong><ul>
<li>类别的霍夫曼码 (from Table K.3, Luminance DC Huffman Code Table)。</li>
<li>幅值的二进制码。</li>
<li><strong>中间符号1 (DC):</strong> (Category, Magnitude_Code)</li>
<li><strong>码流 (DC):</strong> HuffmanCode(Category) || Magnitude_Code</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>AC系数编码：</strong></p>
<ol>
<li><strong>游程编码 (RLE):</strong> 从Zigzag序列的第二个系数开始，扫描AC系数。<ul>
<li>统计连续的0的个数 (RUNLENGTH&#x2F;RRRR)。</li>
<li>下一个非零系数的值 (LEVEL&#x2F;VALUE)。</li>
<li><strong>特殊符号：</strong><ul>
<li>EOB (End of Block): 如果剩下的AC系数都是0，则用一个特殊码 (通常是 (0,0) )表示。</li>
<li>ZRL (Zero Run Length): 如果有超过15个连续的0，则用一个特殊码 (通常是 (15,0) )表示16个0，然后继续计数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>确定 (RUNLENGTH, SIZE) 对：</strong><ul>
<li>RUNLENGTH: 连续0的个数 (0-15)。</li>
<li>SIZE (or Category): 非零AC系数的幅值类别 (类似于DC系数的SSSS，但查AC系数的表)。</li>
</ul>
</li>
<li><strong>确定幅值 (Magnitude&#x2F;ZZZZ…):</strong> 非零AC系数的二进制表示。</li>
<li><strong>霍夫MAN编码：</strong><ul>
<li>(RUNLENGTH, SIZE)对的霍夫曼码 (from Table K.5, Luminance AC Huffman Code Table)。</li>
<li>幅值的二进制码。</li>
<li><strong>中间符号2 (AC):</strong> (Run, Size), Magnitude_Code</li>
<li><strong>码流 (AC):</strong> HuffmanCode(Run, Size) || Magnitude_Code</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>示例 (概念性):</strong> 假设 <code>B1_zigzag_scanned = [52, -5, 0, 3, -2, 0, 0, 1, EOB, ...]</code> (EOB代表后面都是0) 假设 <code>Previous_DC = 40</code></p>
<ul>
<li><p><strong>DC系数:</strong> <code>DC_coeff = 52</code> <code>DIFFERENCE = 52 - 40 = 12</code> 查Table K.3: 12属于类别4 (SSSS&#x3D;4)。幅值码是 ‘1100’。 假设类别4的霍夫曼码是 ‘100’ (查表)。 DC码流: ‘100’ + ‘1100’ &#x3D; ‘1001100’</p>
</li>
<li><p><strong>AC系数:</strong></p>
<ol>
<li><code>-5</code>: RUNLENGTH&#x3D;0. <code>-5</code> 属于类别3 (SIZE&#x3D;3)。幅值码是 ‘010’ (5的反码是…1010，取后3位)。 假设 (0,3) 的霍夫曼码是 ‘01’ (查Table K.5)。 AC码流1: ‘01’ + ‘010’ &#x3D; ‘01010’</li>
<li><code>0, 3</code>: RUNLENGTH&#x3D;1. <code>3</code> 属于类别2 (SIZE&#x3D;2). 幅值码是 ‘11’. 假设 (1,2) 的霍夫曼码是 ‘11010’ (查Table K.5)。 AC码流2: ‘11010’ + ‘11’ &#x3D; ‘1101011’</li>
<li><code>-2</code>: RUNLENGTH&#x3D;0. <code>-2</code> 属于类别2 (SIZE&#x3D;2). 幅值码是 ‘01’. 假设 (0,2) 的霍夫曼码是 ‘00’ (查Table K.5)。 AC码流3: ‘00’ + ‘01’ &#x3D; ‘0001’</li>
<li><code>0, 0, 1</code>: RUNLENGTH&#x3D;2. <code>1</code> 属于类别1 (SIZE&#x3D;1). 幅值码是 ‘1’. 假设 (2,1) 的霍夫曼码是 ‘11111001’ (查Table K.5)。 AC码流4: ‘11111001’ + ‘1’ &#x3D; ‘111110011’</li>
<li><code>EOB</code>: 假设 EOB (0,0) 的霍夫曼码是 ‘1010’ (查Table K.5)。 AC码流_EOB: ‘1010’</li>
</ol>
</li>
<li><p><strong>该块的总码流 (B1_bitstream):</strong> DC码流 + AC码流1 + AC码流2 + … + AC码流_EOB <code>B1_bitstream = &#39;1001100&#39; + &#39;01010&#39; + &#39;1101011&#39; + &#39;0001&#39; + &#39;111110011&#39; + &#39;1010&#39;</code></p>
</li>
</ul>
<p>  <strong>MATLAB实现提示：</strong> 你需要将JPEG标准中的霍夫曼表（K.3, K.5等）硬编码到你的MATLAB脚本中，通常是以cell数组或结构体的形式存储码字和对应的(类别)或(Run,Size)。然后根据计算出的DIFFERENCE、(RUNLENGTH, SIZE)查找对应的霍夫曼码。</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">% --- DC Coefficient Encoding ---</span><br><span class="line">dc_coeff = B1_zigzag_scanned(1);</span><br><span class="line">% Assume previous_dc_coeff is available (for first block, it&#x27;s 0)</span><br><span class="line">% For simplicity, let&#x27;s assume previous_dc_coeff = 0 for this standalone block example.</span><br><span class="line">% In a real sequence, you&#x27;d track it.</span><br><span class="line">previous_dc_coeff = 0; % Placeholder</span><br><span class="line">diff_dc = dc_coeff - previous_dc_coeff;</span><br><span class="line"></span><br><span class="line">% [dc_category, dc_magnitude_code] = get_dc_category_and_magnitude(diff_dc); % User function</span><br><span class="line">% dc_huffman_code = lookup_dc_huffman_table(dc_category); % User function using Table K.3</span><br><span class="line"></span><br><span class="line">% For example:</span><br><span class="line">% if diff_dc == 0, category = 0, magnitude_code = &#x27;&#x27;</span><br><span class="line">% if diff_dc &gt; 0, category = floor(log2(diff_dc)) + 1, magnitude_code = dec2bin(diff_dc)</span><br><span class="line">% if diff_dc &lt; 0, category = floor(log2(abs(diff_dc))) + 1, magnitude_code = dec2bin(bitcmp(uint16(abs(diff_dc)), category)) % Be careful with negative num representation</span><br><span class="line"></span><br><span class="line">% disp([&#x27;DC diff: &#x27;, num2str(diff_dc)]);</span><br><span class="line">% disp([&#x27;DC Category (SSSS): &#x27;, num2str(dc_category)]); % Intermediate Symbol 1 (part 1)</span><br><span class="line">% disp([&#x27;DC Magnitude Code: &#x27;, dc_magnitude_code]);     % Intermediate Symbol 1 (part 2)</span><br><span class="line">% disp([&#x27;DC Huffman Code: &#x27;, dc_huffman_code]);</span><br><span class="line">% block_bitstream = dc_huffman_code;</span><br><span class="line">% block_bitstream = [block_bitstream, dc_magnitude_code];</span><br><span class="line"></span><br><span class="line">% --- AC Coefficient Encoding ---</span><br><span class="line">ac_coeffs = B1_zigzag_scanned(2:end);</span><br><span class="line">run_length = 0;</span><br><span class="line">% ac_bitstream_part = &#x27;&#x27;;</span><br><span class="line">% for i = 1:length(ac_coeffs)</span><br><span class="line">%     if ac_coeffs(i) == 0</span><br><span class="line">%         run_length = run_length + 1;</span><br><span class="line">%         if run_length == 16 % ZRL</span><br><span class="line">%             % [ac_huff_code_zrl] = lookup_ac_huffman_table(15, 0); % (15,0) for ZRL from Table K.5</span><br><span class="line">%             % ac_bitstream_part = [ac_bitstream_part, ac_huff_code_zrl];</span><br><span class="line">%             run_length = 0;</span><br><span class="line">%         end</span><br><span class="line">%     else % Non-zero AC coefficient</span><br><span class="line">%         level = ac_coeffs(i);</span><br><span class="line">%         % [ac_size, ac_magnitude_code] = get_ac_size_and_magnitude(level); % User function</span><br><span class="line">%         % [ac_huff_code] = lookup_ac_huffman_table(run_length, ac_size); % User function from Table K.5</span><br><span class="line">%</span><br><span class="line">%         % disp([&#x27;AC (Run, Size): (&#x27;, num2str(run_length), &#x27;,&#x27;, num2str(ac_size), &#x27;)&#x27;]); % Intermediate Symbol 2 (part 1)</span><br><span class="line">%         % disp([&#x27;AC Magnitude Code: &#x27;, ac_magnitude_code]); % Intermediate Symbol 2 (part 2)</span><br><span class="line">%         % disp([&#x27;AC Huffman Code for (Run,Size): &#x27;, ac_huff_code]);</span><br><span class="line">%</span><br><span class="line">%         % ac_bitstream_part = [ac_bitstream_part, ac_huff_code, ac_magnitude_code];</span><br><span class="line">%         run_length = 0;</span><br><span class="line">%     end</span><br><span class="line">% end</span><br><span class="line">% If last coefficient was zero or loop finishes, add EOB</span><br><span class="line">% [ac_huff_code_eob] = lookup_ac_huffman_table(0, 0); % (0,0) for EOB from Table K.5</span><br><span class="line">% ac_bitstream_part = [ac_bitstream_part, ac_huff_code_eob];</span><br><span class="line">% block_bitstream = [block_bitstream, ac_bitstream_part];</span><br><span class="line"></span><br><span class="line">disp(&#x27;3.5 Entropy Coding:&#x27;);</span><br><span class="line">disp(&#x27;Due to complexity, a full Huffman coding implementation is omitted here.&#x27;);</span><br><span class="line">disp(&#x27;You need to implement Huffman table lookups for DC (Table K.3) and AC (Table K.5).&#x27;);</span><br><span class="line">disp(&#x27;Intermediate Symbol 1 (DC): (Category, Magnitude_Code)&#x27;);</span><br><span class="line">disp(&#x27;Intermediate Symbol 2 (AC): (Run, Size), Magnitude_Code&#x27;);</span><br><span class="line">disp(&#x27;Final Bitstream for B1: Concatenation of Huffman codes and magnitude codes.&#x27;);</span><br><span class="line">% disp([&#x27;Example B1 bitstream (conceptual): &#x27;, block_bitstream]);</span><br></pre></td></tr></table></figure>
<p>  <strong>重要提示：</strong> 实现完整的JPEG熵编码（特别是查表和构造码流）是相当细致的工作。你需要非常仔细地参照JPEG标准文档中的附录K。</p>
</li>
</ul>
<hr>
<p><strong>4. 对F2进行帧间编码（以第一帧的重建帧F1’为参考帧）</strong></p>
<p><strong>4.1 运动估计</strong> 在F2中自选一个4*4的块B2，利用全搜索算法进行运动估计，全搜索的matlab代码可在理工智课下载。给出各个搜索点对应的运动矢量MV及其绝对误差和SAE，并确定出最优的运动矢量：</p>
<ul>
<li><p><strong>准备数据：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% 假设F2已读取并转为灰度double</span><br><span class="line">% F2 = imread(&#x27;your_frame_F2.png&#x27;);</span><br><span class="line">% F2_gray = rgb2gray(F2);</span><br><span class="line">% F2_double = double(F2_gray);</span><br><span class="line"></span><br><span class="line">% F1_prime_double = F1_reconstructed_double; % 来自第2步的重建帧</span><br><span class="line"></span><br><span class="line">% 选择F2中的一个4x4块 B2</span><br><span class="line">% 例如，选择F2中 (r_start, c_start) 开始的4x4块</span><br><span class="line">r_start_B2 = 10; c_start_B2 = 10; % 示例坐标</span><br><span class="line">B2 = F2_double(r_start_B2 : r_start_B2+3, c_start_B2 : c_start_B2+3);</span><br><span class="line">disp(&#x27;4.1 Motion Estimation for B2:&#x27;);</span><br><span class="line">disp(&#x27;Selected B2 from F2:&#x27;);</span><br><span class="line">disp(B2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全搜索算法 (Full Search Algorithm):</strong></p>
<ol>
<li><strong>定义搜索窗口：</strong> 在参考帧 <code>F1_prime_double</code> 中，以块 <code>B2</code> 在 <code>F2</code> 中的相同位置为中心，定义一个搜索范围 (e.g., +&#x2F;-7 像素水平和垂直，即15x15的搜索区域)。</li>
<li><strong>遍历搜索点：</strong> 在搜索窗口内，逐个像素移动参考块 (与<code>B2</code>同样大小，4x4)。</li>
<li><strong>计算匹配准则：</strong> 对于每一个搜索到的候选块，与 <code>B2</code> 计算SAD (Sum of Absolute Differences) 或 SAE (Sum of Absolute Errors)。 SAE(dx,dy)&#x3D;∑i&#x3D;0N−1​∑j&#x3D;0M−1​∣B2(i,j)−F1ref′​(i+dx,j+dy)∣ 其中 (dx, dy) 是运动矢量，N&#x3D;4, M&#x3D;4。 F1ref′​(i+dx,j+dy) 是参考帧中对应位置的块。</li>
<li><strong>确定最优运动矢量：</strong> 具有最小SAE的(dx, dy)即为最优运动矢量。</li>
</ol>
</li>
<li><p><strong>MATLAB 实现 (概念，依赖 “理工智课” 的代码或自己实现):</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">search_range = 7; % 例如 +/-7 像素搜索范围</span><br><span class="line">min_sae = inf;</span><br><span class="line">best_mv = [0, 0];</span><br><span class="line">[rows_f1, cols_f1] = size(F1_prime_double);</span><br><span class="line"></span><br><span class="line">disp(&#x27;Search Points, MVs, and SAEs:&#x27;);</span><br><span class="line"></span><br><span class="line">% B2的中心在F1&#x27;中的对应位置</span><br><span class="line">center_r_f1 = r_start_B2;</span><br><span class="line">center_c_f1 = c_start_B2;</span><br><span class="line"></span><br><span class="line">for dy = -search_range : search_range</span><br><span class="line">    for dx = -search_range : search_range</span><br><span class="line">        % 当前搜索的参考块的左上角坐标</span><br><span class="line">        ref_r_start = center_r_f1 + dy;</span><br><span class="line">        ref_c_start = center_c_f1 + dx;</span><br><span class="line"></span><br><span class="line">        % 检查边界</span><br><span class="line">        if (ref_r_start &gt;= 1 &amp;&amp; ref_r_start+3 &lt;= rows_f1 &amp;&amp; ...</span><br><span class="line">            ref_c_start &gt;= 1 &amp;&amp; ref_c_start+3 &lt;= cols_f1)</span><br><span class="line"></span><br><span class="line">            ref_block = F1_prime_double(ref_r_start : ref_r_start+3, ref_c_start : ref_c_start+3);</span><br><span class="line">            current_sae = sum(abs(B2(:) - ref_block(:)));</span><br><span class="line"></span><br><span class="line">            fprintf(&#x27;MV = (%d, %d), SAE = %f\n&#x27;, dx, dy, current_sae);</span><br><span class="line"></span><br><span class="line">            if current_sae &lt; min_sae</span><br><span class="line">                min_sae = current_sae;</span><br><span class="line">                best_mv = [dx, dy]; % 通常MV定义为 (当前帧位置 - 参考帧位置)</span><br><span class="line">                                  % 或者 (参考帧位置 - 当前帧位置)</span><br><span class="line">                                  % 这里 dx, dy 是参考帧相对于当前帧块的偏移</span><br><span class="line">                                  % 如果MV = Pred_pos - Curr_pos, 则 MV = [dx, dy]</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Optimal Motion Vector (MV_x, MV_y) = (%d, %d) with SAE = %f\n&#x27;, best_mv(1), best_mv(2), min_sae);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4.2 利用运动矢量进行运动补偿后获得帧间预测残差矩阵E（4*4）：</strong></p>
<ul>
<li><p><strong>运动补偿：</strong> 使用找到的最优运动矢量 <code>best_mv</code> 从参考帧 <code>F1_prime_double</code> 中提取预测块 <code>P</code>。</p>
</li>
<li><p><strong>计算残差：</strong> E&#x3D;B2−P</p>
</li>
<li><p><strong>MATLAB 计算：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">predicted_block_r_start = r_start_B2 + best_mv(2); %  MV_y</span><br><span class="line">predicted_block_c_start = c_start_B2 + best_mv(1); %  MV_x</span><br><span class="line"></span><br><span class="line">% 确保预测块在F1&#x27;的边界内</span><br><span class="line">if (predicted_block_r_start &gt;= 1 &amp;&amp; predicted_block_r_start+3 &lt;= rows_f1 &amp;&amp; ...</span><br><span class="line">    predicted_block_c_start &gt;= 1 &amp;&amp; predicted_block_c_start+3 &lt;= cols_f1)</span><br><span class="line">    P_B2 = F1_prime_double(predicted_block_r_start : predicted_block_r_start+3, ...</span><br><span class="line">                           predicted_block_c_start : predicted_block_c_start+3);</span><br><span class="line">else</span><br><span class="line">    % 如果超出边界，通常用边界像素填充或使用一个默认块</span><br><span class="line">    % 为简化，这里假设总在边界内，实际编码器需要处理边界情况</span><br><span class="line">    P_B2 = zeros(4,4); % 或者其他填充策略</span><br><span class="line">    disp(&#x27;Warning: Predicted block for MV is out of F1&#x27;&#x27; bounds. Using zero block for P_B2.&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">E_B2 = B2 - P_B2; % 残差矩阵</span><br><span class="line"></span><br><span class="line">disp(&#x27;4.2 Inter-prediction Residual Matrix E (4x4):&#x27;);</span><br><span class="line">disp(E_B2);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4.3 对于残差矩阵E进行H.264标准的整数DCT变换和量化，给出逐步计算的结果：</strong></p>
<ul>
<li><p><strong>H.264 4x4 整数变换 (Integer DCT-like transform):</strong> H.264 使用的是一种整数变换，它是DCT的近似，但只使用整数运算。 变换公式: Y&#x3D;Cf​XCfT​ 其中 X 是输入的4x4残差块 EB2​， Cf​ 是变换矩阵： Cf​&#x3D;![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
  c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
  -36,557 l0,1284c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
  949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
  c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
  -544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
  l0,-1292c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
  -210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"></path></svg>)​1211​11−1−2​1−1−12​1−21−1​![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
  63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
  c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1209
  c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
  c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
  c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
  c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
  l0,-1344c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
  -470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"></path></svg>)​ 变换后的系数矩阵 Y 中的元素需要进行后续的缩放（这是H.264变换与量化紧密结合的一部分）。</p>
<p>  一个完整的变换与缩放过程可以表示为 W&#x3D;(Cf​XCfT​)⊗Ef​，其中 ⊗ 是元素 Hadamard 乘积， Ef​ 是一个缩放矩阵： Ef​&#x3D;![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
  c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
  -36,557 l0,1284c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
  949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
  c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
  -544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
  l0,-1292c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
  -210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"></path></svg>)​a2ab&#x2F;2a2ab&#x2F;2​ab&#x2F;2b2&#x2F;4ab&#x2F;2b2&#x2F;4​a2ab&#x2F;2a2ab&#x2F;2​ab&#x2F;2b2&#x2F;4ab&#x2F;2b2&#x2F;4​![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
  63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
  c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1209
  c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
  c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
  c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
  c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
  l0,-1344c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
  -470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"></path></svg>)​ 其中 a&#x3D;1&#x2F;2, b&#x3D;1&#x2F;2![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
  c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
  c340,-704.7,510.7,-1060.3,512,-1067
  l0 -0
  c4.7,-7.3,11,-11,19,-11
  H40000v40H1012.3
  s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
  c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
  s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
  c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
  M1001 80h400000v40h-400000z"></path></svg>)​≈0.707 (实际H.264中这些因子被整合到量化步骤的乘法因子和移位中，避免浮点运算)。</p>
<p>  <strong>核心变换 (Forward transform core coefficients):</strong> Yij​&#x3D;∑k​∑l​Cik​Xkl​(CT)lj​ 实际上，H.264标准定义的是整数运算后的系数，然后通过量化参数QP进行量化。</p>
<p>  <strong>简化版整数变换（只考虑核心变换 Y&#x3D;Cf​XCfT​）：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cf = [ 1  1  1  1;</span><br><span class="line">       2  1 -1 -2;</span><br><span class="line">       1 -1 -1  1;</span><br><span class="line">       1 -2  2 -1 ];</span><br><span class="line"></span><br><span class="line">Y_B2 = Cf * E_B2 * Cf&#x27;; % 核心变换</span><br><span class="line">disp(&#x27;4.3.1 H.264 Integer Transformed Coefficients (before scaling/quant):&#x27;);</span><br><span class="line">disp(Y_B2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>H.264 量化:</strong> 量化公式 (简化形式，实际更复杂，涉及QP和预计算的乘法因子和移位): Zij​&#x3D;round(Yij​&#x2F;Qstep​) 或者更接近H.264标准的形式（对于帧内预测的亮度残差系数，这里是帧间）： Levelij​&#x3D;(Wij​⋅MFij​+f)&gt;&gt;(qbits+shift) 其中 Wij​ 是变换系数，MFij​ 是量化参数QP相关的乘法因子，f 是加性偏移（用于近似round），<code>&gt;&gt;</code> 是右移。 qbits&#x3D;15+⌊QP&#x2F;6⌋ MF 依赖于 QP(mod6) 和系数位置 (i,j)。</p>
<p>  <strong>为简化演示，我们使用一个非常简化的量化，假设一个 Qstep​:</strong> 你需要选择一个量化参数QP。QP决定了 Qstep​。 例如，对于一个给定的QP，可以有一个对应的 Qstep​。 H.264的量化表和QP到 Qstep​ 的映射比JPEG复杂。 Qstep​ 大约每增加6个QP值就翻倍。</p>
<p>  <strong>一个非常非常简化的例子（不完全符合H.264标准，仅为演示步骤）：</strong> 假设我们选择一个QP，它对应一个 Qstep​。 例如，如果QP&#x3D;26, Qstep​ 可能近似为 10 (这只是一个示意值)。</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">QP = 26; % Example Quantization Parameter</span><br><span class="line">% In H.264, Qstep is derived from QP and coefficient position.</span><br><span class="line">% For this example, let&#x27;s use a placeholder Qstep.</span><br><span class="line">% A rough Qstep might be derived, e.g. Qstep_base * 2^(QP/6).</span><br><span class="line">% Or use pre-defined scaling factors based on QP % 6 and QP / 6.</span><br><span class="line"></span><br><span class="line">% H.264 has 6 quantization scaling factors for each QP/6 level (V[][])</span><br><span class="line">% and a scaling factor based on QP%6 (PF[][])</span><br><span class="line">% LevelScale( qP, i, j ) = PF[qP%6][(i*4+j)% ( (i==0||i==2)&amp;&amp;(j==0||j==2) ? 3:1 ) ] &lt;&lt; (qP/6)</span><br><span class="line">% QuantizedCoeff = sign(TransformedCoeff) * ( abs(TransformedCoeff) * V[qP%6][(i*4+j)%...] + offset ) &gt;&gt; ( 15 + qP/6 )</span><br><span class="line"></span><br><span class="line">% Simplified Quantization (conceptual for assignment unless deep dive required)</span><br><span class="line">% This does NOT reflect the full H.264 quantization.</span><br><span class="line">% The true H.264 quantization is:</span><br><span class="line">% Z_ij = sign(Y_ij) * (|Y_ij| * MF + f) &gt;&gt; (15 + floor(QP/6))</span><br><span class="line">% where MF depends on QP%6 and coefficient position (i,j) from a table,</span><br><span class="line">% f is an offset (e.g., 2^(14+floor(QP/6)) for intra, smaller for inter)</span><br><span class="line"></span><br><span class="line">% Let&#x27;s create a placeholder quantization matrix based on QP for demonstration</span><br><span class="line">% This is NOT standard but illustrates the step.</span><br><span class="line">% The actual MF values are in tables like Table 7-9 in H.264 spec.</span><br><span class="line">% For simplicity, let&#x27;s use a flat Qstep, which is a gross simplification.</span><br><span class="line">Qstep_example = 10 * (2^(QP/6 - 4)); % Very rough illustrative Qstep</span><br><span class="line"></span><br><span class="line">E_B2_quantized = round(Y_B2 / Qstep_example);</span><br><span class="line"></span><br><span class="line">disp([&#x27;4.3.2 H.264 Quantized Coefficients (using QP=&#x27;, num2str(QP), &#x27; and simplified Qstep=&#x27;, num2str(Qstep_example), &#x27;):&#x27;]);</span><br><span class="line">disp(E_B2_quantized);</span><br><span class="line"></span><br><span class="line">disp(&#x27;NOTE: The H.264 quantization shown above is highly simplified.&#x27;);</span><br><span class="line">disp(&#x27;A proper implementation requires using H.264 standard tables for MF and f based on QP.&#x27;);</span><br><span class="line">disp(&#x27;The core integer transform part Y = Cf * E_B2 * Cf&#x27;&#x27; is correct.&#x27;);</span><br><span class="line">disp(&#x27;For accurate quantization, refer to H.264 standard section 7.4.5.&#x27;);</span><br></pre></td></tr></table></figure>
<p>  <strong>逐步计算：</strong></p>
<ol>
<li>原始残差块 EB2​</li>
<li>计算 Temp&#x3D;EB2​⋅CfT​</li>
<li>计算 YB2​&#x3D;Cf​⋅Temp (核心变换结果)</li>
<li>对 YB2​ 的每个系数，应用H.264量化公式（涉及QP、MF、移位等）。</li>
</ol>
</li>
</ul>
<p><strong>4.4 Zigzag形扫描与熵编码，根据H.264的熵编码顺序，给出逐步熵编码的产生的码流，给出该4*4块B2最终的的码流：（可能用到的表格为H.264标准文档中Table 9.5 ~9.10）</strong></p>
<ul>
<li><p><strong>4x4 Zigzag扫描：</strong> H.264对4x4块的扫描通常也是Zigzag，但根据预测模式（如帧内4x4, 帧间等）可以有不同的扫描顺序。对于帧间残差，通常是标准的Zigzag。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  1  4  5</span><br><span class="line">2  3  6  7</span><br><span class="line">8  9 12 13</span><br><span class="line">10 11 14 15</span><br></pre></td></tr></table></figure>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% 4x4 Zigzag scan order</span><br><span class="line">zigzag_order_4x4 = [</span><br><span class="line">     0  1  4  5</span><br><span class="line">     2  3  6  7</span><br><span class="line">     8  9 12 13</span><br><span class="line">    10 11 14 15</span><br><span class="line">] + 1; % MATLAB 1-indexed</span><br><span class="line"></span><br><span class="line">B2_quant_zigzag = zeros(1, 16);</span><br><span class="line">temp_B2_quant = E_B2_quantized&#x27;; % Transpose for column-major scan</span><br><span class="line">for i = 1:16</span><br><span class="line">    B2_quant_zigzag(i) = temp_B2_quant(zigzag_order_4x4(i));</span><br><span class="line">end</span><br><span class="line">disp(&#x27;4.4.1 Zigzag scanned quantized coefficients for B2 residual:&#x27;);</span><br><span class="line">disp(B2_quant_zigzag);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>熵编码 (CAVLC - Context-Adaptive Variable Length Coding):</strong> H.264对残差系数的熵编码（主要是CAVLC或CABAC）非常复杂。CAVLC是 baseline profile 的标准。 CAVLC编码一个块的非零系数的过程：</p>
<ol>
<li><p><strong>编码 <code>coeff_token</code>:</strong></p>
<ul>
<li>取决于 <code>TotalCoeffs</code> (块中非零系数的个数) 和 <code>TrailingOnes</code> (尾随的 +&#x2F;-1 的个数，最多3个)。</li>
<li><code>coeff_token</code> 从特定的VLC表 (Table 9-5, Table 9-6 in H.264) 中查找，基于 <code>TotalCoeffs</code> 和 <code>TrailingOnes</code>。上下文模型也可能影响表的选择 (e.g., nC: a measure of previously coded non-zero coefficients in neighboring blocks).</li>
</ul>
</li>
<li><p><strong>编码 <code>TrailingOnes</code> 的符号:</strong> 每个 <code>TrailingOne</code> 的符号用1比特表示 (0 for +, 1 for -)。</p>
</li>
<li><p><strong>编码剩下非零系数的 <code>level</code>:</strong></p>
<ul>
<li>从后往前（不包括 <code>TrailingOnes</code>）编码每个非零系数的 <code>level</code> (幅值)。</li>
<li>使用 Golomb-Rice codes 或 Exp-Golomb codes (VLC tables)。</li>
</ul>
</li>
<li><p><strong>编码 <code>TotalZeros</code>:</strong></p>
<ul>
<li>编码在最后一个非零系数之前的所有0的总数 (<code>TotalZeros</code>)。</li>
<li>使用VLC表 (Table 9-7)，基于 <code>TotalCoeffs</code>。</li>
</ul>
</li>
<li><p><strong>编码每个非零系数前的 <code>run_before</code> (0的游程):</strong></p>
<ul>
<li>从后往前，为每个非零系数（不包括最后一个）编码其前面有多少个0 (<code>run_before</code>)。</li>
<li>使用VLC表 (Table 9-8, 9-9, 9-10)，取决于 <code>zerosLeft</code> (尚未编码的0的个数)。</li>
<li>如果所有剩余的0都在第一个非零系数之前，则不需要再编码 <code>run_before</code>。</li>
</ul>
</li>
</ol>
<p>  <strong>逐步熵编码的码流 (CAVLC 概念性示例):</strong> 假设 <code>B2_quant_zigzag = [3, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code></p>
<ol>
<li><code>TotalCoeffs = 3</code></li>
<li><code>TrailingOnes</code>:<ul>
<li><code>1</code> is a trailing one.</li>
<li><code>-1</code> is a trailing one.</li>
<li><code>3</code> is not. So, <code>TrailingOnes = 2</code>.</li>
</ul>
</li>
<li><strong><code>coeff_token</code>:</strong> 查找Table 9-5 (假设nC &lt; 2) for <code>TotalCoeffs=3</code>, <code>TrailingOnes=2</code>. 假设码字是 <code>&#39;0000110&#39;</code></li>
<li><strong>Signs of TrailingOnes:</strong><ul>
<li>For <code>1</code>: sign is <code>+</code> (code <code>0</code>)</li>
<li>For <code>-1</code>: sign is <code>-</code> (code <code>1</code>) TrailingOnes signs bitstream: <code>&#39;01&#39;</code></li>
</ul>
</li>
<li><strong>Levels of remaining coeffs (scan reverse, skip TrailingOnes):</strong><ul>
<li>Remaining coeff is <code>3</code>.</li>
<li>Encode <code>level</code> &#x3D; <code>3</code>. (Using Exp-Golomb or similar, e.g., <code>00100</code> for <code>3</code> if <code>level_prefix</code> and <code>level_suffix</code> rules are applied). Let’s say <code>level_code_for_3 = &#39;00111&#39;</code> (this is an example, actual code depends on specific Exp-Golomb parameters&#x2F;tables used by CAVLC for levels).</li>
</ul>
</li>
<li><strong><code>TotalZeros</code>:</strong><ul>
<li>Last non-zero coeff is <code>1</code> (at index 3 in zigzag). Before it, there is one <code>0</code> (at index 1).</li>
<li>So <code>TotalZeros = 1</code>.</li>
<li>Lookup Table 9-7 for <code>TotalCoeffs=3</code>, <code>TotalZeros=1</code>. Assume code is <code>&#39;11&#39;</code>.</li>
</ul>
</li>
<li><strong><code>run_before</code> for each coeff (scan reverse, stop before last):</strong><ul>
<li>Coeff <code>-1</code> (at index 2): <code>run_before</code> (zeros before it since previous non-zero) &#x3D; <code>1</code> (the zero at index 1). <code>zerosLeft</code> is initially <code>TotalZeros = 1</code>. Lookup Table (e.g., 9-10) for <code>run_before=1</code> given <code>zerosLeft=1</code>. Assume code is <code>&#39;1&#39;</code>. <code>zerosLeft</code> becomes 0.</li>
<li>Coeff <code>3</code> (at index 0): This is the first non-zero coeff to be considered in this step (after trailing ones). No more runs to code if <code>zerosLeft</code> is 0 or it’s the first significant coeff. (The logic for <code>run_before</code> is intricate; it’s about runs of zeros <em>between</em> the non-zero AC coefficients being coded in this phase).</li>
</ul>
</li>
</ol>
<p>  <strong>最终码流 (B2_final_bitstream_CAVLC):</strong> <code>&#39;0000110&#39; (coeff_token) + &#39;01&#39; (signs) + &#39;00111&#39; (level for 3) + &#39;11&#39; (TotalZeros) + &#39;1&#39; (run_before for -1)</code> <code>= &#39;00001100100111111&#39;</code></p>
<p>  <strong>MATLAB实现提示：</strong> CAVLC的完整实现非常复杂，需要仔细处理上下文、查多个VLC表、以及管理系数的扫描顺序。</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;4.4.2 H.264 Entropy Coding (CAVLC):&#x27;);</span><br><span class="line">disp(&#x27;CAVLC is complex. The following is a conceptual outline:&#x27;);</span><br><span class="line">disp(&#x27;1. Calculate TotalCoeffs and TrailingOnes from B2_quant_zigzag.&#x27;);</span><br><span class="line">disp(&#x27;2. Encode coeff_token (using Table 9-5/9-6 based on nC, TotalCoeffs, TrailingOnes).&#x27;);</span><br><span class="line">%   [coeff_token_bits] = get_coeff_token_cavlc(TotalCoeffs, TrailingOnes, nC_value);</span><br><span class="line">disp(&#x27;3. Encode signs of TrailingOnes (1 bit each).&#x27;);</span><br><span class="line">%   [trailing_ones_sign_bits] = get_trailing_ones_signs(B2_quant_zigzag, TrailingOnes);</span><br><span class="line">disp(&#x27;4. Encode levels of remaining non-zero coefficients (Exp-Golomb).&#x27;);</span><br><span class="line">%   [levels_bits] = encode_levels_cavlc(B2_quant_zigzag, TotalCoeffs, TrailingOnes);</span><br><span class="line">disp(&#x27;5. Encode TotalZeros (zeros before last non-zero coeff, Table 9-7).&#x27;);</span><br><span class="line">%   [total_zeros_bits] = encode_total_zeros_cavlc(B2_quant_zigzag, TotalCoeffs);</span><br><span class="line">disp(&#x27;6. Encode run_before for zeros preceding each non-zero coeff (Tables 9-8/9-9/9-10).&#x27;);</span><br><span class="line">%   [runs_bits] = encode_runs_cavlc(B2_quant_zigzag, TotalCoeffs, TotalZeros);</span><br><span class="line">% block_B2_final_stream = [coeff_token_bits, trailing_ones_sign_bits, levels_bits, total_zeros_bits, runs_bits];</span><br><span class="line">disp(&#x27;The final bitstream for B2 is the concatenation of these parts.&#x27;);</span><br><span class="line">disp(&#x27;Actual bit values require implementing the lookup for H.264 Tables 9-5 to 9-10.&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>这是一个相当全面的大作业。在MATLAB中实现这些，特别是JPEG的完整熵编码和H.264的CAVLC，需要花费大量时间和精力进行调试。建议你分模块实现和测试，并仔细阅读相关的标准文档。</p>
<p>祝你顺利完成作业！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">电机驱动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:14:32" itemprop="dateModified" datetime="2025-05-31T13:14:32+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E7%89%A9/" itemprop="url" rel="index"><span itemprop="name">杂物</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基于STM32F103C8T6的机器人小车电机驱动与PID控制设计"><a href="#基于STM32F103C8T6的机器人小车电机驱动与PID控制设计" class="headerlink" title="基于STM32F103C8T6的机器人小车电机驱动与PID控制设计"></a>基于STM32F103C8T6的机器人小车电机驱动与PID控制设计</h1><h2 id="第1节：STM32F103C8T6与机器人小车电机控制概述"><a href="#第1节：STM32F103C8T6与机器人小车电机控制概述" class="headerlink" title="第1节：STM32F103C8T6与机器人小车电机控制概述"></a>第1节：STM32F103C8T6与机器人小车电机控制概述</h2><h3 id="1-1-STM32F103C8T6微控制器概览"><a href="#1-1-STM32F103C8T6微控制器概览" class="headerlink" title="1.1. STM32F103C8T6微控制器概览"></a>1.1. STM32F103C8T6微控制器概览</h3><p>STM32F103C8T6是一款基于ARM Cortex-M3内核的32位微控制器，由意法半导体（STMicroelectronics）生产。其核心特性包括高达72 MHz的工作频率、64KB的Flash程序存储器和20KB的SRAM 1。这些特性使其成为各种嵌入式控制应用的理想选择，尤其是在机器人技术领域。</p>
<p>对于电机控制而言，STM32F103C8T6的以下外设至关重要：</p>
<ul>
<li><strong>通用输入&#x2F;输出（GPIO）引脚：</strong> 该微控制器提供多达37个I&#x2F;O引脚 1，可用于配置电机驱动器的方向控制信号，并与其他传感器或模块进行通信。</li>
<li><strong>定时器（TIM）：</strong> STM32F103C8T6内置多个通用定时器（如TIM1、TIM2、TIM3、TIM4）和高级控制定时器（部分型号）。这些定时器能够产生脉冲宽度调制（PWM）信号，这是控制直流电机速度的关键技术 1。此外，定时器还可以配置为编码器接口模式，用于读取电机转速和位置信息，这对于实现闭环控制（如PID）至关重要。</li>
</ul>
<p>尽管STM32F103C8T6被归类为“中等密度”设备 1，但其提供的外设组合对于控制一个双电机机器人小车来说已经绰绰有余，即使是包含PID算法和编码器反馈的复杂控制系统。其72MHz的最高主频确保了控制回路能够及时执行，满足实时性要求。</p>
<h3 id="1-2-差速驱动机器人小车"><a href="#1-2-差速驱动机器人小车" class="headerlink" title="1.2. 差速驱动机器人小车"></a>1.2. 差速驱动机器人小车</h3><p>差速驱动是一种常见的机器人移动平台设计，它通过独立驱动位于共同轴线上的两个轮子来实现运动和转向 5。其基本运动方式如下：</p>
<ul>
<li><strong>前进&#x2F;后退：</strong> 两个轮子以相同的速度和相同的方向旋转。</li>
<li><strong>转向（原地旋转&#x2F;曲线转向）：</strong> 两个轮子以不同的速度旋转，或者以相反的方向旋转。例如，要使小车左转，可以使右轮转速高于左轮，或者使左轮反转而右轮正转 6。</li>
</ul>
<p>差速驱动的优势在于其机械结构简单，控制相对直接。</p>
<h3 id="1-3-电机驱动器的作用"><a href="#1-3-电机驱动器的作用" class="headerlink" title="1.3. 电机驱动器的作用"></a>1.3. 电机驱动器的作用</h3><p>微控制器（MCU）的GPIO引脚通常无法直接驱动直流电机，因为电机所需的电流和电压超出了MCU引脚的承受能力。因此，电机驱动器扮演了至关重要的角色。</p>
<p>H桥电路是电机驱动器的核心技术，它允许通过切换电路中晶体管的导通状态来改变流过电机电流的方向，从而实现电机的双向控制 7。电机驱动器将来自MCU的低功率控制信号（如方向信号和PWM信号）转换为驱动电机所需的高功率信号。这种分离不仅保护了MCU免受电机大电流的冲击，还确保了电机能够获得稳定高效的能量供应。在后续章节中，将详细介绍具体的电机驱动器IC。</p>
<h2 id="第2节：硬件搭建与注意事项"><a href="#第2节：硬件搭建与注意事项" class="headerlink" title="第2节：硬件搭建与注意事项"></a>第2节：硬件搭建与注意事项</h2><h3 id="2-1-选择电机驱动器IC"><a href="#2-1-选择电机驱动器IC" class="headerlink" title="2.1. 选择电机驱动器IC"></a>2.1. 选择电机驱动器IC</h3><p>为本项目选择合适的电机驱动器IC至关重要。市面上有多种选择，其中L298N和DRV8833是两种常见的适用于此项目的双H桥电机驱动器。</p>
<h4 id="2-1-1-L298N双H桥电机驱动器"><a href="#2-1-1-L298N双H桥电机驱动器" class="headerlink" title="2.1.1. L298N双H桥电机驱动器"></a>2.1.1. L298N双H桥电机驱动器</h4><ul>
<li><strong>描述：</strong> L298N是一款坚固耐用、广泛应用的双H桥电机驱动器，能够独立驱动两个直流电机。它支持较宽的电压范围（最高可达35V-46V）和较大的电流（每通道最高2A）9。</li>
<li><strong>控制逻辑：</strong> 通常，每个电机需要2个输入引脚（如IN1, IN2）来控制方向，以及1个使能引脚（如ENA）通过PWM信号来控制速度 9。参考资料14中的表5清晰地展示了其真值表。</li>
<li><strong>注意事项：</strong> L298N内部晶体管导通时存在约2V的电压降 12，这会导致效率较低，并可能需要比电机额定电压更高的供电电压。在大电流工作时，通常需要加装散热片 12。许多L298N模块集成了板载5V稳压器 8。</li>
</ul>
<h4 id="2-1-2-DRV8833双H桥电机驱动器"><a href="#2-1-2-DRV8833双H桥电机驱动器" class="headerlink" title="2.1.2. DRV8833双H桥电机驱动器"></a>2.1.2. DRV8833双H桥电机驱动器</h4><ul>
<li><strong>描述：</strong> DRV8833是一款更现代、效率更高的电机驱动器，主要得益于其内部集成的低导通电阻（Rds(on)）MOSFET 15。其工作电压范围较低（2.7V - 10.8V），适用于驱动功率较小的电机（每通道RMS电流可达1.5A）15。</li>
<li><strong>控制逻辑：</strong> 与L298N类似，每个H桥也使用2个输入引脚（如xIN1, xIN2）进行方向和速度控制（PWM信号可施加于这些输入引脚）15。参考资料15中的表2详细说明了其控制模式。</li>
<li><strong>特性：</strong> DRV8833通常包含故障检测（nFAULT）和低功耗睡眠模式（nSLEEP）等额外功能 15。</li>
</ul>
<h4 id="2-1-3-比较与推荐"><a href="#2-1-3-比较与推荐" class="headerlink" title="2.1.3. 比较与推荐"></a>2.1.3. 比较与推荐</h4><p>为了帮助用户根据具体需求做出选择，下表对L298N和DRV8833的关键特性进行了比较：</p>
<p><strong>表1：L298N与DRV8833电机驱动器比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>特性</strong></td>
<td><strong>L298N</strong></td>
<td><strong>DRV8833</strong></td>
</tr>
<tr>
<td>工作电压范围</td>
<td>5V - 35V (典型模块, IC本身可达46V 10)</td>
<td>2.7V - 10.8V 15</td>
</tr>
<tr>
<td>每通道最大电流</td>
<td>2A (峰值3A) 11</td>
<td>1.5A RMS, 2A 峰值 15</td>
</tr>
<tr>
<td>效率 (电压降&#x2F;Rds(on))</td>
<td>较低 (电压降约2V 12)</td>
<td>较高 (HS + LS Rds(on) 约 360 mΩ 15)</td>
</tr>
<tr>
<td>封装尺寸&#x2F;集成度</td>
<td>通常为模块形式，体积较大</td>
<td>IC封装较小，模块也相对紧凑</td>
</tr>
<tr>
<td>散热管理</td>
<td>大电流时通常需要散热片 12</td>
<td>视具体应用而定，通常散热需求较低</td>
</tr>
<tr>
<td>板载5V稳压器</td>
<td>许多模块包含 8</td>
<td>通常不包含</td>
</tr>
<tr>
<td>特殊功能</td>
<td>较少</td>
<td>睡眠模式, 故障检测, 过流&#x2F;过温保护 16</td>
</tr>
<tr>
<td>典型成本&#x2F;易得性</td>
<td>成本较低，非常普及</td>
<td>成本略高，也较易获得</td>
</tr>
</tbody></table>
<p>在本报告中，<strong>将以L298N作为详细示例</strong>，因为它在业余爱好者套件中历史悠久且对初学者而言较为坚固。然而，DRV8833作为一种更高效的选择，尤其适用于电池供电或对体积有要求的紧凑型设计，也将被提及。</p>
<p>电机驱动器的选择对整个系统设计具有连锁反应。L298N的电压降可能意味着需要一个比电机名义电压更高的电池组，这会影响机器人的尺寸、重量和成本。许多L298N模块上的板载5V稳压器 8 在电机供电电压合适（例如，小于等于12V 9）时可以简化MCU的供电，但在更高电压下则可能出现问题。相比之下，DRV8833的较低工作电压范围可能更适合直接使用锂电池供电而无需额外稳压，但同时也限制了电机的选择。其高效率则有利于延长电池续航。</p>
<h3 id="2-2-硬件连接图：STM32F103C8T6与L298N及两路直流电机"><a href="#2-2-硬件连接图：STM32F103C8T6与L298N及两路直流电机" class="headerlink" title="2.2. 硬件连接图：STM32F103C8T6与L298N及两路直流电机"></a>2.2. 硬件连接图：STM32F103C8T6与L298N及两路直流电机</h3><p>以下是STM32F103C8T6与L298N模块及两路直流电机连接的详细说明（具体引脚选择可根据实际情况调整，此处为示例）：</p>
<ul>
<li><strong>方向控制：</strong><ul>
<li>STM32 GPIO (例如 PA0) -&gt; L298N IN1 (左电机方向1)</li>
<li>STM32 GPIO (例如 PA1) -&gt; L298N IN2 (左电机方向2)</li>
<li>STM32 GPIO (例如 PA2) -&gt; L298N IN3 (右电机方向1)</li>
<li>STM32 GPIO (例如 PA3) -&gt; L298N IN4 (右电机方向2)</li>
</ul>
</li>
<li><strong>速度控制 (PWM)：</strong><ul>
<li>STM32 定时器PWM输出引脚 (例如 PB0, TIM3_CH3) -&gt; L298N ENA (左电机使能&#x2F;速度)</li>
<li>STM32 定时器PWM输出引脚 (例如 PB1, TIM3_CH4) -&gt; L298N ENB (右电机使能&#x2F;速度)</li>
</ul>
</li>
<li><strong>电源：</strong><ul>
<li>电机电源 (例如 7.4V - 12V 电池组) -&gt; L298N VS (或标有12V输入的端口) 和 GND</li>
<li>电机 -&gt; L298N OUT1&#x2F;OUT2 (左电机) 和 OUT3&#x2F;OUT4 (右电机)</li>
</ul>
</li>
<li><strong>逻辑电源与共地：</strong><ul>
<li>STM32 GND -&gt; L298N GND (共地连接至关重要 9)</li>
<li>L298N逻辑电源 (VSS或模块上的5V引脚)：<ul>
<li>如果电机电源电压小于等于12V，并且L298N模块上的5V使能跳线帽已连接，则此引脚可输出5V，可用于为STM32供电（需注意电流能力）。</li>
<li>如果电机电源电压大于12V，应移除5V使能跳线帽，并从外部为L298N的5V逻辑输入引脚提供稳定的5V电源（例如，从STM32的5V输出引脚，如果STM32板有的话，或者使用独立的5V稳压器）8。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一个清晰的电路连接图对于正确搭建硬件至关重要，具体图示将在报告的相应部分提供（基于11中的原则）。</p>
<h3 id="2-3-电源注意事项"><a href="#2-3-电源注意事项" class="headerlink" title="2.3. 电源注意事项"></a>2.3. 电源注意事项</h3><ul>
<li>通常建议为MCU和电机使用独立的电源，以提高系统稳定性并防止电机噪声干扰MCU。</li>
<li>电池的选择应基于电机的额定电压和电流需求。</li>
<li>STM32F103C8T6通常需要3.3V的稳定电源。“Blue Pill”等常见的STM32F103C8T6开发板通常带有板载3.3V稳压器。</li>
</ul>
<h3 id="2-4-可选但PID控制推荐-旋转编码器"><a href="#2-4-可选但PID控制推荐-旋转编码器" class="headerlink" title="2.4. (可选但PID控制推荐) 旋转编码器"></a>2.4. (可选但PID控制推荐) 旋转编码器</h3><ul>
<li>旋转编码器是一种反馈设备，用于测量电机的转速和&#x2F;或位置 20。</li>
<li>常见的类型是增量式编码器，它输出A、B两相正交脉冲信号。</li>
<li><strong>接线：</strong> 编码器的A、B相输出连接到STM32的定时器输入引脚（配置为编码器接口模式）或配置为外部中断的GPIO引脚。编码器还需要VCC和GND供电 20。</li>
</ul>
<p>尽早引入编码器的概念，即使用户最初不打算实现PID控制，也能为后续的高级控制打下基础，并强调闭环系统反馈的重要性。</p>
<h2 id="第3节：STM32CubeIDE电机控制配置"><a href="#第3节：STM32CubeIDE电机控制配置" class="headerlink" title="第3节：STM32CubeIDE电机控制配置"></a>第3节：STM32CubeIDE电机控制配置</h2><h3 id="3-1-在STM32CubeIDE中设置新工程"><a href="#3-1-在STM32CubeIDE中设置新工程" class="headerlink" title="3.1. 在STM32CubeIDE中设置新工程"></a>3.1. 在STM32CubeIDE中设置新工程</h3><p>STM32CubeIDE是一款集成了STM32CubeMX图形化配置工具的集成开发环境。创建一个新工程的步骤通常包括选择目标MCU型号（STM32F103C8T6），然后利用STM32CubeMX进行引脚和外设的配置 7。</p>
<h3 id="3-2-系统时钟配置"><a href="#3-2-系统时钟配置" class="headerlink" title="3.2. 系统时钟配置"></a>3.2. 系统时钟配置</h3><p>系统时钟（SYSCLK）是MCU执行指令和外设工作的核心。对于STM32F103C8T6，通常将其配置为最大频率72MHz。如果开发板上装有外部高速晶振（HSE），例如“Blue Pill”板上常见的8MHz晶振 24，则应优先使用HSE作为时钟源，并通过PLL倍频到72MHz。同时，需要确保APB1和APB2总线上的外设时钟（PCLK1, PCLK2）也得到正确配置，因为定时器等外设挂载在这些总线上，其工作频率与总线时钟相关 7。</p>
<h3 id="3-3-L298N方向控制的GPIO配置"><a href="#3-3-L298N方向控制的GPIO配置" class="headerlink" title="3.3. L298N方向控制的GPIO配置"></a>3.3. L298N方向控制的GPIO配置</h3><p>为L298N的IN1、IN2、IN3、IN4引脚选择四个STM32F103C8T6的GPIO引脚（例如PA0, PA1, PA2, PA3）。在STM32CubeMX中，将这些引脚配置为“GPIO_Output”模式 7。可以设置初始输出电平（例如，低电平），输出速度。对于推挽输出模式，通常不需要配置上拉或下拉电阻。如果需要更深入地理解GPIO寄存器级别的配置，可以参考STM32参考手册中关于GPIOx_CRL和GPIOx_CRH寄存器的说明 4，但STM32 HAL库对这些底层细节进行了抽象。</p>
<h3 id="3-4-PWM速度控制的定时器配置"><a href="#3-4-PWM速度控制的定时器配置" class="headerlink" title="3.4. PWM速度控制的定时器配置"></a>3.4. PWM速度控制的定时器配置</h3><p>选择STM32F103C8T6上的两个定时器通道用于产生PWM信号，以控制L298N的ENA和ENB引脚（例如，TIM2的通道1和通道2，或者不同定时器的通道，如TIM1的通道1和TIM2的通道1）。所选的GPIO引脚必须是相应定时器通道的PWM输出复用功能引脚 1。</p>
<p>在STM32CubeMX中进行如下配置 4：</p>
<ol>
<li><strong>选择并使能定时器：</strong> 例如，选择TIM2。</li>
<li><strong>设置时钟源：</strong> 选择“Internal Clock”。</li>
<li><strong>配置通道为PWM输出模式：</strong> 例如，将Channel 1和Channel 2配置为“PWM Generation CH1”和“PWM Generation CH2”。</li>
<li><strong>参数设置：</strong><ul>
<li><strong>预分频器 (Prescaler, PSC)：</strong> 用于降低定时器的计数时钟频率。计数器时钟频率 fCK_CNT​ 的计算公式为：fCK_CNT​&#x3D;fAPB_Timer​&#x2F;(PSC+1)，其中 fAPB_Timer​ 是定时器所在的APB总线时钟频率。</li>
<li><strong>计数模式 (Counter Mode)：</strong> 对于PWM生成，通常选择向上计数模式。</li>
<li><strong>计数周期 (Counter Period, Auto-Reload Register - ARR)：</strong> 定义PWM信号的周期，从而决定PWM频率。PWM频率 fPWM​ 的计算公式为：fPWM​&#x3D;fCK_CNT​&#x2F;(ARR+1)。</li>
<li><strong>脉冲宽度 (Pulse, Capture Compare Register - CCRx)：</strong> 定义PWM信号的占空比。占空比 DutyCycle 的计算公式为：DutyCycle&#x3D;(CCRx&#x2F;(ARR+1))×100%。</li>
<li><strong>PWM模式 (PWM Mode)：</strong> 通常选择“PWM Mode 1”或“PWM Mode 2”。<ul>
<li>PWM Mode 1：当 TIMx_CNT&lt;TIMx_CCRx 时，输出有效电平（例如高电平）。</li>
<li>PWM Mode 2：当 TIMx_CNT&gt;TIMx_CCRx 时，输出有效电平（例如高电平）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>PWM频率和分辨率的考量：</p>
<p>PWM频率的选择并非随意。较高的频率可以使电机运行更平稳，减少可闻噪音，但也可能增加电机驱动器的开关损耗。较低的频率可能对电机本身的效率不利。对于L298N，1kHz至20kHz范围内的频率较为常见，例如9中提到了1.5kHz。这是一个需要权衡的参数。PSC和ARR的组合不仅决定PWM频率，也影响PWM的分辨率。较大的ARR值可以提供更精细的占空比控制。</p>
<p>示例计算：</p>
<p>假设APB1定时器时钟为72MHz（假设HCLK未分频直接供给APB1总线上的定时器）。</p>
<p>期望PWM频率为10kHz。</p>
<ul>
<li>方案一：设置PSC &#x3D; 0，则 fCK_CNT​&#x3D;72MHz。此时，ARR&#x3D;(72MHz&#x2F;10kHz)−1&#x3D;7200−1&#x3D;7199。</li>
<li>方案二：设置PSC &#x3D; 71，则 fCK_CNT​&#x3D;72MHz&#x2F;(71+1)&#x3D;1MHz。此时，ARR&#x3D;(1MHz&#x2F;10kHz)−1&#x3D;100−1&#x3D;99。 方案一具有更高的分辨率。</li>
</ul>
<p>完成配置后，从STM32CubeMX生成初始化代码。</p>
<h3 id="3-5-表2：STM32F103C8T6与L298N控制引脚映射示例"><a href="#3-5-表2：STM32F103C8T6与L298N控制引脚映射示例" class="headerlink" title="3.5. 表2：STM32F103C8T6与L298N控制引脚映射示例"></a>3.5. 表2：STM32F103C8T6与L298N控制引脚映射示例</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>STM32 引脚</strong></td>
<td><strong>STM32 功能</strong></td>
<td><strong>L298N 引脚</strong></td>
<td><strong>用途</strong></td>
</tr>
<tr>
<td>PA0</td>
<td>GPIO_Output</td>
<td>IN1</td>
<td>左电机方向控制1</td>
</tr>
<tr>
<td>PA1</td>
<td>GPIO_Output</td>
<td>IN2</td>
<td>左电机方向控制2</td>
</tr>
<tr>
<td>PA2</td>
<td>GPIO_Output</td>
<td>IN3</td>
<td>右电机方向控制1</td>
</tr>
<tr>
<td>PA3</td>
<td>GPIO_Output</td>
<td>IN4</td>
<td>右电机方向控制2</td>
</tr>
<tr>
<td>PB0</td>
<td>TIM3_CH3 (PWM)</td>
<td>ENA</td>
<td>左电机速度控制</td>
</tr>
<tr>
<td>PB1</td>
<td>TIM3_CH4 (PWM)</td>
<td>ENB</td>
<td>右电机速度控制</td>
</tr>
<tr>
<td>3.3V</td>
<td>-</td>
<td>(可选，若L298N模块需要外部5V逻辑供电且STM32有5V输出，则连接至L298N的5V输入，否则L298N的5V由其板载稳压器提供或外部独立5V供电)</td>
<td>L298N逻辑电源</td>
</tr>
<tr>
<td>GND</td>
<td>-</td>
<td>GND</td>
<td>电源地</td>
</tr>
</tbody></table>
<p>此表提供了一个清晰的参考，帮助用户正确连接硬件，并理解MCU各引脚在软件中的角色，从而将软件配置与物理接线联系起来。</p>
<h2 id="第4节：实现机器人小车基本运动-C代码与HAL库"><a href="#第4节：实现机器人小车基本运动-C代码与HAL库" class="headerlink" title="第4节：实现机器人小车基本运动 (C代码与HAL库)"></a>第4节：实现机器人小车基本运动 (C代码与HAL库)</h2><h3 id="4-1-工程结构与HAL初始化"><a href="#4-1-工程结构与HAL初始化" class="headerlink" title="4.1. 工程结构与HAL初始化"></a>4.1. 工程结构与HAL初始化</h3><p>由STM32CubeIDE生成的<code>main.c</code>文件包含了程序的主体结构。在<code>main()</code>函数中，首先会调用<code>HAL_Init()</code>进行HAL库的初始化，接着调用<code>SystemClock_Config()</code>配置系统时钟。之后，由STM32CubeMX生成的GPIO和定时器初始化函数（如<code>MX_GPIO_Init()</code>和<code>MX_TIMx_Init()</code>）也会被调用。</p>
<h3 id="4-2-启动PWM信号"><a href="#4-2-启动PWM信号" class="headerlink" title="4.2. 启动PWM信号"></a>4.2. 启动PWM信号</h3><p>为了使能L298N的速度控制引脚ENA和ENB，需要在相应的定时器初始化之后启动PWM信号。这通过为每个PWM通道调用<code>HAL_TIM_PWM_Start()</code>函数来实现 7。此操作通常在初始化阶段执行一次。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设htim3用于PWM输出，通道3和4分别控制左电机和右电机</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3); <span class="comment">// 启动左电机PWM</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4); <span class="comment">// 启动右电机PWM</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-定义电机和方向类型-示例"><a href="#4-3-定义电机和方向类型-示例" class="headerlink" title="4.3. 定义电机和方向类型 (示例)"></a>4.3. 定义电机和方向类型 (示例)</h3><p>为了提高代码的可读性和可维护性，建议使用<code>typedef enum</code>来定义电机和方向的类型：</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MOTOR_LEFT,</span><br><span class="line">    MOTOR_RIGHT</span><br><span class="line">&#125; Motor_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DIR_FORWARD,</span><br><span class="line">    DIR_BACKWARD,</span><br><span class="line">    DIR_STOP <span class="comment">// 电机停止（通过方向控制引脚）</span></span><br><span class="line">&#125; Direction_TypeDef;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-底层电机控制函数"><a href="#4-4-底层电机控制函数" class="headerlink" title="4.4. 底层电机控制函数"></a>4.4. 底层电机控制函数</h3><h4 id="4-4-1-设置电机PWM速度函数"><a href="#4-4-1-设置电机PWM速度函数" class="headerlink" title="4.4.1. 设置电机PWM速度函数"></a>4.4.1. 设置电机PWM速度函数</h4><p>此函数用于设置指定电机PWM信号的占空比，从而控制电机转速。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  设置电机PWM速度</span></span><br><span class="line"><span class="comment">  * @param  htimx: 定时器句柄指针 (例如 &amp;htim3)</span></span><br><span class="line"><span class="comment">  * @param  TIM_CHANNEL_y: 定时器通道 (例如 TIM_CHANNEL_3)</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_motor_pwm_speed</span><span class="params">(TIM_HandleTypeDef *htimx, <span class="type">uint32_t</span> TIM_CHANNEL_y, <span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> raw_pwm;</span><br><span class="line">    <span class="keyword">if</span> (speed_percentage &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        speed_percentage = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据ARR值计算CCRx的原始值</span></span><br><span class="line">    raw_pwm = (<span class="type">uint16_t</span>)(((<span class="type">float</span>)speed_percentage / <span class="number">100.0f</span>) * htimx-&gt;Instance-&gt;ARR);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(htimx, TIM_CHANNEL_y, raw_pwm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数接收定时器句柄、定时器通道和期望的速度百分比作为参数。它首先将速度百分比转换为对应定时器ARR（自动重载寄存器）值的原始PWM比较值（CCRx），然后使用<code>__HAL_TIM_SET_COMPARE()</code>宏函数来更新PWM的占空比 25。</p>
<h4 id="4-4-2-L298N电机方向控制函数"><a href="#4-4-2-L298N电机方向控制函数" class="headerlink" title="4.4.2. L298N电机方向控制函数"></a>4.4.2. L298N电机方向控制函数</h4><p>此函数根据L298N的控制逻辑，通过设置相应的GPIO引脚电平来控制电机方向。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已在CubeMX中为方向引脚定义了宏，例如:</span></span><br><span class="line"><span class="comment">// #define L_IN1_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define L_IN1_Pin GPIO_PIN_0</span></span><br><span class="line"><span class="comment">// #define L_IN2_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define L_IN2_Pin GPIO_PIN_1</span></span><br><span class="line"><span class="comment">// #define R_IN3_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define R_IN3_Pin GPIO_PIN_2</span></span><br><span class="line"><span class="comment">// #define R_IN4_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define R_IN4_Pin GPIO_PIN_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  设置L298N驱动的电机方向</span></span><br><span class="line"><span class="comment">  * @param  motor: 选择电机 (MOTOR_LEFT 或 MOTOR_RIGHT)</span></span><br><span class="line"><span class="comment">  * @param  direction: 选择方向 (DIR_FORWARD, DIR_BACKWARD, 或 DIR_STOP)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_motor_direction_l298n</span><span class="params">(Motor_TypeDef motor, Direction_TypeDef direction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (motor == MOTOR_LEFT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == DIR_FORWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(L_IN1_GPIO_Port, L_IN1_Pin, GPIO_PIN_SET);   <span class="comment">// IN1 = High</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN2_GPIO_Port, L_IN2_Pin, GPIO_PIN_RESET); <span class="comment">// IN2 = Low</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == DIR_BACKWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(L_IN1_GPIO_Port, L_IN1_Pin, GPIO_PIN_RESET); <span class="comment">// IN1 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN2_GPIO_Port, L_IN2_Pin, GPIO_PIN_SET);   <span class="comment">// IN2 = High</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// DIR_STOP (快速制动)</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN1_GPIO_Port, L_IN1_Pin, GPIO_PIN_RESET); <span class="comment">// IN1 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN2_GPIO_Port, L_IN2_Pin, GPIO_PIN_RESET); <span class="comment">// IN2 = Low</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motor == MOTOR_RIGHT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == DIR_FORWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(R_IN3_GPIO_Port, R_IN3_Pin, GPIO_PIN_SET);   <span class="comment">// IN3 = High</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN4_GPIO_Port, R_IN4_Pin, GPIO_PIN_RESET); <span class="comment">// IN4 = Low</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == DIR_BACKWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(R_IN3_GPIO_Port, R_IN3_Pin, GPIO_PIN_RESET); <span class="comment">// IN3 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN4_GPIO_Port, R_IN4_Pin, GPIO_PIN_SET);   <span class="comment">// IN4 = High</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// DIR_STOP (快速制动)</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN3_GPIO_Port, R_IN3_Pin, GPIO_PIN_RESET); <span class="comment">// IN3 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN4_GPIO_Port, R_IN4_Pin, GPIO_PIN_RESET); <span class="comment">// IN4 = Low</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数使用<code>HAL_GPIO_WritePin()</code>函数 23 来设置L298N的INx引脚电平，遵循L298N的真值表 14。注意，L298N的“停止”可以通过将两个INx引脚都设为低电平（快速制动）或将使能引脚（ENA&#x2F;ENB）设为低电平（自由滑行停止）来实现。上述函数实现了快速制动。</p>
<h3 id="4-5-高层机器人运动函数"><a href="#4-5-高层机器人运动函数" class="headerlink" title="4.5. 高层机器人运动函数"></a>4.5. 高层机器人运动函数</h3><p>基于底层的速度和方向控制函数，可以封装出更高级别的机器人整体运动函数。这种分层设计提高了代码的模块化程度和可重用性。如果将来更换电机驱动器（例如，从L298N换到DRV8833），主要修改可能仅限于底层的方向控制函数，而高层API（如<code>car_forward()</code>）可以保持不变，这大大增强了代码的可维护性和适应性。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设htim_L和htim_R是分别用于左右电机的定时器句柄</span></span><br><span class="line"><span class="comment">// 假设TIM_CHANNEL_L和TIM_CHANNEL_R是对应的PWM通道</span></span><br><span class="line"><span class="keyword">extern</span> TIM_HandleTypeDef htim_L; <span class="comment">// 例如 htim3</span></span><br><span class="line"><span class="keyword">extern</span> TIM_HandleTypeDef htim_R; <span class="comment">// 例如 htim3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM_CHANNEL_L TIM_CHANNEL_3 <span class="comment">// 示例</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM_CHANNEL_R TIM_CHANNEL_4 <span class="comment">// 示例</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车前进</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_forward</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_FORWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_FORWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车后退</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_backward</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_BACKWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_BACKWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车左转 (原地旋转)</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_turn_left_pivot</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_BACKWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_FORWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车右转 (原地旋转)</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_turn_right_pivot</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_FORWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_BACKWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车停止 (通过PWM占空比为0实现，方向控制引脚保持上次状态或设为制动)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_stop_pwm</span><span class="params">()</span> &#123;</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, <span class="number">0</span>);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 可选: 执行快速制动</span></span><br><span class="line">    <span class="comment">// set_motor_direction_l298n(MOTOR_LEFT, DIR_STOP);</span></span><br><span class="line">    <span class="comment">// set_motor_direction_l298n(MOTOR_RIGHT, DIR_STOP);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些高层函数调用了前面定义的底层函数来实现小车的各种运动状态 7。转向策略可以有多种，例如原地旋转（一个轮子前进，另一个轮子后退）或曲线转向（一个轮子比另一个轮子转得快）5。</p>
<h3 id="4-6-主循环测试"><a href="#4-6-主循环测试" class="headerlink" title="4.6. 主循环测试"></a>4.6. 主循环测试</h3><p>在<code>main()</code>函数的<code>while(1)</code>循环中，可以编写简单的测试代码来验证这些运动函数的正确性，例如：</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//... HAL_Init(), SystemClock_Config(), MX_GPIO_Init(), MX_TIM3_Init()...</span></span><br><span class="line">    <span class="comment">// 假设htim_L 和 htim_R 已正确初始化并赋值为 &amp;htim3</span></span><br><span class="line">    <span class="comment">// 假设TIM_CHANNEL_L 和 TIM_CHANNEL_R 已正确定义</span></span><br><span class="line"></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim_L, TIM_CHANNEL_L);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim_R, TIM_CHANNEL_R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        car_forward(<span class="number">50</span>);    <span class="comment">// 前进，速度50%</span></span><br><span class="line">        HAL_Delay(<span class="number">2000</span>);    <span class="comment">// 持续2秒</span></span><br><span class="line">        car_stop_pwm();     <span class="comment">// 停止</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);    <span class="comment">// 停止1秒</span></span><br><span class="line"></span><br><span class="line">        car_turn_left_pivot(<span class="number">30</span>); <span class="comment">// 左转，速度30%</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);    <span class="comment">// 持续1秒</span></span><br><span class="line">        car_stop_pwm();     <span class="comment">// 停止</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);    <span class="comment">// 停止1秒</span></span><br><span class="line">        </span><br><span class="line">        car_backward(<span class="number">50</span>);   <span class="comment">// 后退，速度50%</span></span><br><span class="line">        HAL_Delay(<span class="number">2000</span>);</span><br><span class="line">        car_stop_pwm();</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        car_turn_right_pivot(<span class="number">30</span>); <span class="comment">// 右转，速度30%</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">        car_stop_pwm();</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第5节：PID控制增强性能简介"><a href="#第5节：PID控制增强性能简介" class="headerlink" title="第5节：PID控制增强性能简介"></a>第5节：PID控制增强性能简介</h2><h3 id="5-1-为何需要PID？开环控制的局限性"><a href="#5-1-为何需要PID？开环控制的局限性" class="headerlink" title="5.1. 为何需要PID？开环控制的局限性"></a>5.1. 为何需要PID？开环控制的局限性</h3><p>第4节中实现的基本运动控制属于“开环控制”。这意味着MCU向电机发出指令（例如，设置一定的PWM占空比），但并不关心电机是否真正达到了期望的速度，或者小车是否真的在直线行驶。</p>
<p>开环控制的性能会受到多种因素的影响，例如：</p>
<ul>
<li>电池电压波动：电池电量下降时，相同的PWM占空比可能无法产生相同的电机转速。</li>
<li>地面摩擦力变化：在不同表面行驶时，电机负载会变化。</li>
<li>电机个体差异：即使是同型号的电机，其特性也可能略有不同。</li>
<li>负载变化：小车上装载物品的重量变化。</li>
</ul>
<p>为了克服这些局限性，引入了“闭环控制”策略，其中PID（比例-积分-微分）控制器是最常用的一种。PID控制器通过使用传感器反馈来持续监测系统状态，并根据期望状态与实际状态之间的误差来调整控制输出，从而提高系统的性能和鲁棒性 21。</p>
<h3 id="5-2-PID基本理论解释"><a href="#5-2-PID基本理论解释" class="headerlink" title="5.2. PID基本理论解释"></a>5.2. PID基本理论解释</h3><p>PID控制器的核心思想是根据当前误差、累积误差和误差变化率来计算控制量。</p>
<ul>
<li><strong>误差 (Error, e(t)):</strong> 期望设定点（例如，目标速度）与实际测量过程变量（例如，编码器测得的当前速度）之间的差值 21。</li>
<li><strong>比例 (Proportional, P) 项 (Kp​⋅e(t)):</strong><ul>
<li>控制器输出与当前误差成正比。误差越大，P项产生的校正作用也越大。</li>
<li><strong>作用：</strong> 加快系统响应速度，减小稳态误差，但通常无法完全消除稳态误差。过大的Kp​会导致系统振荡甚至不稳定 21。</li>
</ul>
</li>
<li><strong>积分 (Integral, I) 项 (Ki​⋅∫e(t)dt):</strong><ul>
<li>累积过去的误差。只要存在误差，I项就会持续作用，直到误差被消除。</li>
<li><strong>作用：</strong> 消除系统的稳态误差。过大的Ki​会导致积分饱和（积分 विंडअप），引起系统超调和振荡，响应变慢 21。</li>
</ul>
</li>
<li><strong>微分 (Derivative, D) 项 (Kd​⋅dtde(t)​):</strong><ul>
<li>根据误差的变化率来预测未来的误差趋势，并提前进行校正。</li>
<li><strong>作用：</strong> 减小超调，抑制振荡，改善系统稳定性，加快稳定过程。D项对过程变量中的噪声非常敏感，过大的Kd​或噪声较大的系统可能导致输出剧烈波动 21。</li>
</ul>
</li>
</ul>
<p>PID控制律公式：</p>
<p>控制器的输出 Output(t) 由这三项加权求和得到：</p>
<p>Output(t)&#x3D;Kp​e(t)+Ki​∫0t​e(τ)dτ+Kd​dtde(t)​</p>
<p>其中，Kp​, Ki​, Kd​ 分别是比例、积分和微分增益系数，需要根据具体系统进行整定 21。</p>
<p>理解P、I、D各项的独立作用及其组合效应是PID参数整定的基础。每个参数都针对系统响应的不同方面进行调整。PID控制器本质上是试图基于当前和过去的状态来预测未来并进行修正，从而使系统能够自适应地达到期望状态。</p>
<h3 id="5-3-反馈的必要性：引入编码器"><a href="#5-3-反馈的必要性：引入编码器" class="headerlink" title="5.3. 反馈的必要性：引入编码器"></a>5.3. 反馈的必要性：引入编码器</h3><p>为了使PID控制器能够工作，必须能够测量“过程变量”（例如电机速度）。旋转编码器是电机控制中常用的传感器，用于提供这种反馈 20。编码器产生的脉冲信号可以被转换成电机的速度或位置信息。下一节将详细介绍如何在STM32F103C8T6上集成和读取编码器数据。</p>
<h2 id="第6节：STM32F103C8T6集成编码器"><a href="#第6节：STM32F103C8T6集成编码器" class="headerlink" title="第6节：STM32F103C8T6集成编码器"></a>第6节：STM32F103C8T6集成编码器</h2><h3 id="6-1-理解正交编码器"><a href="#6-1-理解正交编码器" class="headerlink" title="6.1. 理解正交编码器"></a>6.1. 理解正交编码器</h3><p>正交编码器（或称A&#x2F;B相编码器）通常有两个输出通道，分别称为A相和B相。这两个通道输出方波脉冲信号，并且A相和B相信号之间存在90度的相位差。通过检测这两个信号的脉冲数量和相位关系，可以确定电机旋转的距离（或角度）和方向 20。编码器的一个关键参数是每转脉冲数（Pulses Per Revolution, PPR），它表示电机轴旋转一周时，A相或B相输出的脉冲个数 33。</p>
<h3 id="6-2-配置STM32定时器的编码器模式"><a href="#6-2-配置STM32定时器的编码器模式" class="headerlink" title="6.2. 配置STM32定时器的编码器模式"></a>6.2. 配置STM32定时器的编码器模式</h3><p>STM32微控制器的通用定时器（例如STM32F103上的TIM1, TIM2, TIM3, TIM4，具体型号需查阅数据手册确认是否支持编码器接口）可以配置为“编码器接口模式”，从而硬件解码编码器信号 20。</p>
<p><strong>STM32CubeMX 设置步骤 20:</strong></p>
<ol>
<li><strong>选择合适的定时器：</strong> 例如，选择TIM3。</li>
<li><strong>使能编码器模式：</strong> 在定时器的“Combined Channels”配置中，选择“Encoder Mode”。</li>
<li><strong>配置编码器接口参数：</strong><ul>
<li><strong>Encoder Mode：</strong> 选择“Encoder Mode TI1 and TI2”。这将使用定时器的两个输入通道（TI1FP1和TI2FP2）分别连接编码器的A相和B相信号。</li>
<li><strong>Counter Period (ARR)：</strong> 对于16位定时器，通常将ARR设置为最大值65535（0xFFFF），以允许在计数器溢出前回转较大范围。也可以根据期望的计数行为进行配置。</li>
<li><strong>Input Filter (ICx Filter)：</strong> 可以为输入通道配置数字滤波器，以减少外部噪声对编码器信号的干扰。</li>
</ul>
</li>
<li><strong>GPIO引脚配置：</strong> 连接到编码器A相和B相的GPIO引脚（例如，TIM3_CH1和TIM3_CH2对应的引脚）将自动配置为定时器输入复用功能。</li>
<li><strong>启动定时器：</strong> 在代码中，使用 <code>HAL_TIM_Encoder_Start(&amp;htim_encoder, TIM_CHANNEL_ALL);</code> 启动定时器的编码器模式 20。</li>
</ol>
<p>一旦配置完成并启动，定时器的计数器寄存器（TIMx-&gt;CNT）会根据编码器的旋转自动增加或减少。</p>
<p>使用硬件编码器模式比通过外部中断手动处理编码器脉冲要高效得多，尤其是在电机转速较高时。它将计数和方向检测的任务卸载到硬件，从而释放CPU资源 [39 (Scott Seidman的评论), 20]。</p>
<h3 id="6-3-读取编码器计数并计算速度"><a href="#6-3-读取编码器计数并计算速度" class="headerlink" title="6.3. 读取编码器计数并计算速度"></a>6.3. 读取编码器计数并计算速度</h3><h4 id="6-3-1-读取原始计数值"><a href="#6-3-1-读取原始计数值" class="headerlink" title="6.3.1. 读取原始计数值"></a>6.3.1. 读取原始计数值</h4><p>启动编码器模式后，可以通过读取定时器的计数器寄存器来获取原始计数值：</p>
<p>current_counts &#x3D; __HAL_TIM_GET_COUNTER(&amp;htim_encoder); 20。</p>
<h4 id="6-3-2-计算速度-例如，每采样时间的脉冲数或RPM"><a href="#6-3-2-计算速度-例如，每采样时间的脉冲数或RPM" class="headerlink" title="6.3.2. 计算速度 (例如，每采样时间的脉冲数或RPM)"></a>6.3.2. 计算速度 (例如，每采样时间的脉冲数或RPM)</h4><p>速度的计算需要周期性地采样编码器的计数值。可以使用另一个定时器产生周期性中断（例如，每10ms或100ms）来进行速度计算。</p>
<ol>
<li><p>在一个固定的采样时间间隔 Δt 内，读取编码器计数值的变化量 Δcounts：</p>
<p> Δcounts&#x3D;current_counts−previous_counts</p>
<p> 需要处理计数器溢出&#x2F;下溢的情况，特别是当ARR值不是足够大或者位置信息发生回绕时 20。对于16位计数器和ARR&#x3D;65535，当从0xFFFF变为0x0000（正转）或从0x0000变为0xFFFF（反转）时，需要特殊处理差值。</p>
</li>
<li><p>将脉冲数转换为转速（例如，RPM - 每分钟转数）：</p>
<p> SpeedRPS​&#x3D;(Δcounts&#x2F;PPRencoder​)&#x2F;Δtseconds​ (转&#x2F;秒)</p>
<p> SpeedRPM​&#x3D;SpeedRPS​×60 (转&#x2F;分钟)</p>
<p> 其中，PPRencoder​ 是编码器每转产生的脉冲数，Δtseconds​ 是采样时间间隔（以秒为单位）。</p>
<p> 例如，34 提供了一个RPM计算公式：rpm&#x3D;(timer_counter&#x2F;encoder_counts_per_rev)×60.0。这里的 timer_counter 对应于 Δcounts，encoder_counts_per_rev 对应于 PPRencoder​，并且假设这个计算是在1秒的时间间隔内完成的。</p>
<p> 36 中描述的M方法公式为 n&#x3D;M0​&#x2F;(C⋅T0​)，其中 M0​ 是 Δcounts，C 是 PPRencoder​，T0​ 是采样时间 Δtseconds​。</p>
</li>
</ol>
<h4 id="6-3-3-C代码结构示例-编码器读取与速度计算"><a href="#6-3-3-C代码结构示例-编码器读取与速度计算" class="headerlink" title="6.3.3. C代码结构示例 (编码器读取与速度计算)"></a>6.3.3. C代码结构示例 (编码器读取与速度计算)</h4><p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码器数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TIM_HandleTypeDef* htim;         <span class="comment">// 编码器定时器句柄</span></span><br><span class="line">    <span class="type">int16_t</span>            previous_counter_value; <span class="comment">// 上一次的计数值 (假设为16位定时器)</span></span><br><span class="line">    <span class="type">int32_t</span>            current_position;       <span class="comment">// 累积的位置 (可选)</span></span><br><span class="line">    <span class="type">float</span>              current_speed_rps;    <span class="comment">// 当前速度 (转/秒)</span></span><br><span class="line">    <span class="type">uint16_t</span>           ppr;                  <span class="comment">// 编码器每转脉冲数</span></span><br><span class="line">    <span class="type">uint32_t</span>           last_update_tick;     <span class="comment">// 上次更新速度的时间戳 (ms)</span></span><br><span class="line">    <span class="type">float</span>              sample_time_seconds;  <span class="comment">// 速度计算的采样周期 (秒)</span></span><br><span class="line">&#125; Encoder_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：在定时器中断服务程序中更新速度</span></span><br><span class="line"><span class="comment">// 假设此函数由一个周期性定时器中断调用，例如每10ms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_UpdateSpeed</span><span class="params">(Encoder_TypeDef* encoder)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> current_tick = HAL_GetTick();</span><br><span class="line">    <span class="type">int16_t</span> current_counter = (<span class="type">int16_t</span>)__HAL_TIM_GET_COUNTER(encoder-&gt;htim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算计数值差值，考虑16位计数器溢出</span></span><br><span class="line">    <span class="type">int16_t</span> diff = current_counter - encoder-&gt;previous_counter_value;</span><br><span class="line">    <span class="comment">// 简单的溢出处理：如果差值绝对值大于半个计数范围，则认为发生了溢出</span></span><br><span class="line">    <span class="comment">// (0xFFFF / 2 = 32767)</span></span><br><span class="line">    <span class="comment">// if (diff &gt; 30000) &#123; // 假设反向溢出 (e.g., 0 -&gt; 65530)</span></span><br><span class="line">    <span class="comment">//     diff -= 65536;</span></span><br><span class="line">    <span class="comment">// &#125; else if (diff &lt; -30000) &#123; // 假设正向溢出 (e.g., 65530 -&gt; 0)</span></span><br><span class="line">    <span class="comment">//     diff += 65536;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 更稳健的溢出处理可能需要更复杂的逻辑或依赖于定时器更新事件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> time_elapsed_seconds = (<span class="type">float</span>)(current_tick - encoder-&gt;last_update_tick) / <span class="number">1000.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (time_elapsed_seconds &gt;= encoder-&gt;sample_time_seconds) &#123; <span class="comment">// 确保达到采样周期</span></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;ppr &gt; <span class="number">0</span> &amp;&amp; time_elapsed_seconds &gt; <span class="number">0.0001f</span>) &#123; <span class="comment">// 防止除以零</span></span><br><span class="line">            encoder-&gt;current_speed_rps = ((<span class="type">float</span>)diff / (<span class="type">float</span>)encoder-&gt;ppr) / time_elapsed_seconds;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encoder-&gt;current_speed_rps = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encoder-&gt;previous_counter_value = current_counter;</span><br><span class="line">        encoder-&gt;last_update_tick = current_tick;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可选：累积位置</span></span><br><span class="line">        <span class="comment">// encoder-&gt;current_position += diff;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>速度计算的准确性和频率直接影响PID控制的性能。一个充满噪声的速度信号（例如，来自低PPR编码器或更新频率不足）会使PID参数整定变得困难，并可能导致系统不稳定，尤其是当微分项（Kd）增益较高时。因此，选择合适的编码器和设计恰当的速度计算周期非常重要。</p>
<h2 id="第7节：实现电机PID速度控制-C代码与HAL库"><a href="#第7节：实现电机PID速度控制-C代码与HAL库" class="headerlink" title="第7节：实现电机PID速度控制 (C代码与HAL库)"></a>第7节：实现电机PID速度控制 (C代码与HAL库)</h2><h3 id="7-1-PID数据结构定义"><a href="#7-1-PID数据结构定义" class="headerlink" title="7.1. PID数据结构定义"></a>7.1. PID数据结构定义</h3><p>为每个需要PID控制的电机定义一个C结构体，用于存储PID参数和相关的状态变量 21。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> Kp;                   <span class="comment">// 比例增益</span></span><br><span class="line">    <span class="type">float</span> Ki;                   <span class="comment">// 积分增益</span></span><br><span class="line">    <span class="type">float</span> Kd;                   <span class="comment">// 微分增益</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> setpoint;             <span class="comment">// 目标设定值 (例如，期望速度 RPS)</span></span><br><span class="line">    <span class="type">float</span> last_error;           <span class="comment">// 上一次的误差</span></span><br><span class="line">    <span class="type">float</span> integral_sum;         <span class="comment">// 积分累计值</span></span><br><span class="line">    <span class="type">float</span> integral_max;         <span class="comment">// 积分累计值的上限 (用于抗积分饱和)</span></span><br><span class="line">    <span class="type">float</span> integral_min;         <span class="comment">// 积分累计值的下限</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> output_min;           <span class="comment">// PID输出值的下限 (例如，PWM占空比的最小值0)</span></span><br><span class="line">    <span class="type">float</span> output_max;           <span class="comment">// PID输出值的上限 (例如，PWM占空比的最大值100)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于基于时间的PID计算</span></span><br><span class="line">    <span class="comment">// uint32_t last_compute_time;  // 上次计算PID的时间戳</span></span><br><span class="line">    <span class="comment">// float sample_time_seconds;   // PID计算周期 (秒)</span></span><br><span class="line">&#125; PID_Controller_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为左右电机分别实例化PID控制器</span></span><br><span class="line">PID_Controller_TypeDef pid_left_motor;</span><br><span class="line">PID_Controller_TypeDef pid_right_motor;</span><br></pre></td></tr></table></figure>

<p>这种结构化方法有助于管理多个PID控制器的参数和状态，例如在双电机驱动的机器人小车中，左右轮通常需要独立的PID控制器 21。</p>
<h3 id="7-2-PID初始化函数-pid-init"><a href="#7-2-PID初始化函数-pid-init" class="headerlink" title="7.2. PID初始化函数 pid_init()"></a>7.2. PID初始化函数 <code>pid_init()</code></h3><p>创建一个函数来初始化PID控制器的参数，包括增益系数、设定点（可以后续修改）、输出限制、积分限制和采样时间。同时，重置误差和积分累积值。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  初始化PID控制器参数</span></span><br><span class="line"><span class="comment">  * @param  pid: 指向PID控制器结构体的指针</span></span><br><span class="line"><span class="comment">  * @param  Kp: 比例增益</span></span><br><span class="line"><span class="comment">  * @param  Ki: 积分增益</span></span><br><span class="line"><span class="comment">  * @param  Kd: 微分增益</span></span><br><span class="line"><span class="comment">  * @param  setpoint: 初始目标设定值</span></span><br><span class="line"><span class="comment">  * @param  out_min: PID输出下限</span></span><br><span class="line"><span class="comment">  * @param  out_max: PID输出上限</span></span><br><span class="line"><span class="comment">  * @param  integral_limit: 积分累积值的绝对值上限</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pid_init</span><span class="params">(PID_Controller_TypeDef* pid, <span class="type">float</span> Kp, <span class="type">float</span> Ki, <span class="type">float</span> Kd, </span></span><br><span class="line"><span class="params">              <span class="type">float</span> setpoint, <span class="type">float</span> out_min, <span class="type">float</span> out_max, <span class="type">float</span> integral_limit)</span> &#123;</span><br><span class="line">    pid-&gt;Kp = Kp;</span><br><span class="line">    pid-&gt;Ki = Ki;</span><br><span class="line">    pid-&gt;Kd = Kd;</span><br><span class="line">    pid-&gt;setpoint = setpoint;</span><br><span class="line">    pid-&gt;output_min = out_min;</span><br><span class="line">    pid-&gt;output_max = out_max;</span><br><span class="line">    pid-&gt;integral_max = integral_limit;</span><br><span class="line">    pid-&gt;integral_min = -integral_limit; <span class="comment">// 对称的积分限制</span></span><br><span class="line"></span><br><span class="line">    pid-&gt;last_error = <span class="number">0.0f</span>;</span><br><span class="line">    pid-&gt;integral_sum = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// pid-&gt;last_compute_time = HAL_GetTick(); // 如果使用基于时间戳的dt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此初始化函数参考了21中的<code>set_pid</code>和37中的<code>PID</code>构造函数的设计思想。</p>
<h3 id="7-3-PID计算函数-pid-compute"><a href="#7-3-PID计算函数-pid-compute" class="headerlink" title="7.3. PID计算函数 pid_compute()"></a>7.3. PID计算函数 <code>pid_compute()</code></h3><p>此函数将周期性地被调用（例如，每隔一个固定的<code>sample_time_seconds</code>），根据当前测量值计算PID输出。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  执行PID计算</span></span><br><span class="line"><span class="comment">  * @param  pid: 指向PID控制器结构体的指针</span></span><br><span class="line"><span class="comment">  * @param  current_value: 当前测量值 (例如，当前电机速度 RPS)</span></span><br><span class="line"><span class="comment">  * @param  dt: 离散时间间隔 (两次计算之间的时间差，单位：秒)</span></span><br><span class="line"><span class="comment">  * @retval float: PID计算得到的输出值 (例如，PWM占空比百分比)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">pid_compute</span><span class="params">(PID_Controller_TypeDef* pid, <span class="type">float</span> current_value, <span class="type">float</span> dt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dt &lt;= <span class="number">0.0f</span>) &#123; <span class="comment">// 防止dt为零或负数导致计算错误</span></span><br><span class="line">        <span class="keyword">return</span> pid-&gt;output_min; <span class="comment">// 或返回上一次的有效输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 计算误差</span></span><br><span class="line">    <span class="type">float</span> error = pid-&gt;setpoint - current_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 比例项</span></span><br><span class="line">    <span class="type">float</span> P_term = pid-&gt;Kp * error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 积分项 (带抗积分饱和)</span></span><br><span class="line">    pid-&gt;integral_sum += pid-&gt;Ki * error * dt;</span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;integral_sum &gt; pid-&gt;integral_max) &#123;</span><br><span class="line">        pid-&gt;integral_sum = pid-&gt;integral_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;integral_sum &lt; pid-&gt;integral_min) &#123;</span><br><span class="line">        pid-&gt;integral_sum = pid-&gt;integral_min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> I_term = pid-&gt;integral_sum; <span class="comment">// 在某些实现中，I_term = Ki * integral_sum</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 微分项</span></span><br><span class="line">    <span class="type">float</span> derivative = (error - pid-&gt;last_error) / dt;</span><br><span class="line">    <span class="type">float</span> D_term = pid-&gt;Kd * derivative;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新上一次误差，用于下次微分计算</span></span><br><span class="line">    pid-&gt;last_error = error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 计算总输出</span></span><br><span class="line">    <span class="type">float</span> output = P_term + I_term + D_term;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 输出限幅</span></span><br><span class="line">    <span class="keyword">if</span> (output &gt; pid-&gt;output_max) &#123;</span><br><span class="line">        output = pid-&gt;output_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output &lt; pid-&gt;output_min) &#123;</span><br><span class="line">        output = pid-&gt;output_min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此计算函数参考了21的<code>apply_pid</code>和37的<code>PID_Compute</code>以及21中的PID实现逻辑。在积分项和微分项的计算中，<code>dt</code>（时间间隔）应该是两次PID计算之间的_实际_经过时间，而不是简单地使用配置的采样时间。这可以通过<code>HAL_GetTick()</code>来测量，以获得更准确的控制，尤其是在控制循环的定时不是绝对精确的情况下。</p>
<h3 id="7-4-将PID输出应用于PWM占空比"><a href="#7-4-将PID输出应用于PWM占空比" class="headerlink" title="7.4. 将PID输出应用于PWM占空比"></a>7.4. 将PID输出应用于PWM占空比</h3><p><code>pid_compute()</code>函数返回的<code>output</code>值（例如，范围在0到100之间，如果<code>output_min/max</code>如此设置）需要被映射到控制电机PWM的占空比范围（例如，对于定时器的ARR值为999，则PWM原始值范围为0-999）。</p>
<p>如果PID的输出设计为可以为负值（例如，当PID同时控制方向和速度时），则输出的符号可以决定电机方向，其绝对值决定PWM大小。但在本报告中，我们假设方向由高层函数（如<code>car_forward</code>）独立控制，PID仅输出一个正值（0-100）来控制速度大小。</p>
<p>可以使用第4节中定义的set_motor_pwm_speed()函数来应用PID计算得到的PWM占空比：</p>
<p>set_motor_pwm_speed(&amp;htim_motor, TIM_CHANNEL_MOTOR, (uint8_t)pid_output);</p>
<p>其中pid_output是pid_compute返回的经过限幅的控制量。</p>
<h3 id="7-5-带PID的主控制循环"><a href="#7-5-带PID的主控制循环" class="headerlink" title="7.5. 带PID的主控制循环"></a>7.5. 带PID的主控制循环</h3><ol>
<li>初始化左右电机的PID控制器（调用<code>pid_init()</code>）。</li>
<li>初始化编码器，并启动周期性的速度计算（例如，通过定时器中断）。</li>
<li>在一个周期性循环中（例如，由一个专用定时器中断触发，中断周期为PID的<code>sample_time_seconds</code>）： a. 从编码器获取左右电机的当前速度（<code>current_speed_L</code>, <code>current_speed_R</code>）。 b. 计算自上次PID计算以来经过的实际时间<code>dt</code>。 c. 根据用户输入或更高级别的导航逻辑，设置左右电机的期望速度（<code>pid_left_motor.setpoint</code>, <code>pid_right_motor.setpoint</code>）。 d. 为左电机计算PID输出：<code>pwm_L = pid_compute(&amp;pid_left_motor, current_speed_L, dt);</code> e. 为右电机计算PID输出：<code>pwm_R = pid_compute(&amp;pid_right_motor, current_speed_R, dt);</code> f. 根据期望的运动方向（例如，如果设定点为负，则方向为反向，但这需要PID输出和方向逻辑的配合），设置电机方向。为简化起见，这里假设PID输出始终为正（0-100），方向由<code>car_forward()</code>等函数预先设定。 g. 将计算得到的<code>pwm_L</code>（经过适当转换）应用到左电机的PWM控制引脚（ENA）。 h. 将计算得到的<code>pwm_R</code>（经过适当转换）应用到右电机的PWM控制引脚（ENB）。</li>
</ol>
<p>PID控制回路、编码器读数和PWM更新必须仔细定时和同步。使用硬件定时器中断来执行主PID控制循环，可以确保一致的执行时序，这对于PID控制的稳定性至关重要。这种系统集成确保了控制器能够基于最新的反馈信息做出及时响应。</p>
<h2 id="第8节：PID控制器参数整定"><a href="#第8节：PID控制器参数整定" class="headerlink" title="第8节：PID控制器参数整定"></a>第8节：PID控制器参数整定</h2><h3 id="8-1-整定的目标"><a href="#8-1-整定的目标" class="headerlink" title="8.1. 整定的目标"></a>8.1. 整定的目标</h3><p>PID参数整定的目标是找到一组Kp​,Ki​,Kd​值，使得控制系统对于特定的机器人小车能够表现出稳定且良好的动态性能：快速的响应时间、最小的超调量、较短的稳定时间以及零稳态误差（或在可接受范围内）32。</p>
<h3 id="8-2-手动整定方法-试凑法"><a href="#8-2-手动整定方法-试凑法" class="headerlink" title="8.2. 手动整定方法 (试凑法)"></a>8.2. 手动整定方法 (试凑法)</h3><p>这是一种常用的、基于经验的整定方法 30：</p>
<ol>
<li><strong>从P控制器开始：</strong> 将Ki​和Kd​设为0。</li>
<li><strong>调整Kp​：</strong> 从一个较小的值开始，逐渐增加Kp​。观察系统响应（例如，电机速度达到设定值的过程）。目标是获得一个相对较快且没有持续振荡的响应。如果系统开始出现持续振荡或变得不稳定，则减小Kp​。通常将Kp​设置在系统开始轻微振荡的临界值的50%-70%左右。</li>
<li><strong>加入I控制器：</strong> 在选定的Kp​值基础上，从一个较小的值开始逐渐增加Ki​。Ki​的作用是消除稳态误差。观察系统是否能够最终达到设定点。如果Ki​过大，可能会导致超调增加、响应变慢或产生振荡（积分饱和）。如果需要，可以回头微调Kp​。</li>
<li><strong>加入D控制器 (如果需要)：</strong> 如果系统在P和I控制下仍存在较大的超调或振荡，可以尝试加入一个较小的Kd​值来抑制这些现象，提高系统的阻尼。Kd​对系统噪声敏感，因此不宜设置过大。在许多速度控制应用中，PD或PI控制器可能就足够了，不一定需要完整的PID。</li>
<li><strong>迭代优化：</strong> PID参数整定通常是一个迭代的过程。对一个参数的调整可能会影响其他参数的最佳值。需要耐心观察和反复试验。</li>
</ol>
<h3 id="8-3-Kp​-Ki​-Kd​对系统响应的影响"><a href="#8-3-Kp​-Ki​-Kd​对系统响应的影响" class="headerlink" title="8.3. Kp​,Ki​,Kd​对系统响应的影响"></a>8.3. Kp​,Ki​,Kd​对系统响应的影响</h3><p>下表总结了各PID参数对系统响应特性的主要影响 21：</p>
<p><strong>表3：PID参数整定指南</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数</strong></td>
<td><strong>增大该参数的影响</strong></td>
<td><strong>减小该参数的影响</strong></td>
<td><strong>参数过大的常见问题</strong></td>
</tr>
<tr>
<td>Kp​</td>
<td>加快响应速度，减小稳态误差，增加系统振荡性</td>
<td>减慢响应速度，增大稳态误差，减小系统振荡性</td>
<td>剧烈超调，持续振荡，系统不稳定</td>
</tr>
<tr>
<td>Ki​</td>
<td>消除稳态误差，可能增加超调和稳定时间</td>
<td>稳态误差较大，响应可能更快（如果Ki​之前过大）</td>
<td>积分饱和，超调过大，响应缓慢，系统振荡</td>
</tr>
<tr>
<td>Kd​</td>
<td>减小超调，缩短稳定时间，提高系统稳定性，对噪声敏感</td>
<td>增加超调，延长稳定时间，可能降低稳定性</td>
<td>放大高频噪声，导致输出抖动，系统不稳定</td>
</tr>
</tbody></table>
<p>此表为用户在整定过程中提供了一个快速参考，帮助理解参数调整的后果并解决常见的整定问题。</p>
<h3 id="8-4-机器人小车PID整定实用技巧"><a href="#8-4-机器人小车PID整定实用技巧" class="headerlink" title="8.4. 机器人小车PID整定实用技巧"></a>8.4. 机器人小车PID整定实用技巧</h3><ul>
<li><strong>独立测试：</strong> 首先在机器人轮子离地或机器人被架空的情况下，对单个电机的速度控制环进行整定。</li>
<li><strong>参数迁移：</strong> 一个电机整定完成后，可以将得到的参数作为另一个电机PID控制器的初始参数。由于电机和机械结构可能存在差异，通常还需要对第二个电机进行微调。</li>
<li><strong>实地测试：</strong> 在机器人实际运行的地面上进行最终测试和调整，因为地面摩擦力会影响系统响应。</li>
<li><strong>数据记录与可视化：</strong> 通过串口将设定点、当前速度、PID输出等数据发送到PC端，并使用串口助手或绘图工具（如STM32CubeIDE的SWV功能 20，或自定义的绘图软件）进行可视化。这有助于直观地分析系统响应曲线，从而更有效地进行参数调整。</li>
<li><strong>差速驱动的协调：</strong> 对于差速驱动机器人，要实现直线行驶，两轮的PID控制器都需要良好整定，并且两轮的设定速度必须相等。由于机械差异，可能需要为左右轮设置略微不同的PID增益。更高级的控制策略可能包括一个上层控制器，用于校正航向偏差（例如，使用IMU反馈）或确保两轮行驶距离一致（例如，通过PID控制两轮编码器计数的差值 38）。</li>
<li><strong>注意安全：</strong> 在整定过程中，电机可能会突然高速旋转或反向，确保机器人处于安全的环境中，避免损坏或伤人。</li>
</ul>
<h3 id="8-5-Ziegler-Nichols整定法-简述"><a href="#8-5-Ziegler-Nichols整定法-简述" class="headerlink" title="8.5. Ziegler-Nichols整定法 (简述)"></a>8.5. Ziegler-Nichols整定法 (简述)</h3><p>Ziegler-Nichols方法是一种启发式的PID参数整定方法，适用于手动整定较为困难的系统 30。它通常包括两个步骤：首先，在纯比例控制（Ki​&#x3D;0,Kd​&#x3D;0）下，找到使系统产生持续等幅振荡的临界比例增益Ku​和此时的振荡周期Tu​。然后根据Ku​和Tu​的值，通过经验公式计算出Kp​,Ki​,Kd​的初始值。</p>
<h2 id="第9节：总结与展望"><a href="#第9节：总结与展望" class="headerlink" title="第9节：总结与展望"></a>第9节：总结与展望</h2><h3 id="9-1-成果总结"><a href="#9-1-成果总结" class="headerlink" title="9.1. 成果总结"></a>9.1. 成果总结</h3><p>本报告详细阐述了如何使用STM32F103C8T6微控制器设计和实现一个双轮差速驱动机器人小车的电机控制系统。内容涵盖了STM32CubeIDE的配置、L298N电机驱动器的接口与控制、通过PWM实现电机调速、集成旋转编码器以获取速度反馈，以及PID控制理论的讲解和C语言实现。通过本报告的学习，用户应能够：</p>
<ul>
<li>理解STM32F103C8T6在电机控制中的关键外设（GPIO、TIM）。</li>
<li>掌握电机驱动器的基本原理和使用方法。</li>
<li>实现小车的基本运动控制（前进、后退、转向）。</li>
<li>配置STM32定时器读取编码器数据并计算速度。</li>
<li>理解PID控制算法的原理，并能将其应用于电机速度闭环控制。</li>
<li>初步掌握PID参数的手动整定方法。</li>
</ul>
<h3 id="9-2-完整示例代码结构-概念性"><a href="#9-2-完整示例代码结构-概念性" class="headerlink" title="9.2. 完整示例代码结构 (概念性)"></a>9.2. 完整示例代码结构 (概念性)</h3><p>一个完整的项目代码通常会包含以下模块化的文件结构：</p>
<ul>
<li><code>main.c</code>: 主程序文件，包含初始化调用和主循环。</li>
<li><code>motor_control.h</code> &#x2F; <code>motor_control.c</code>: 包含电机底层控制函数（方向、PWM设置）和高层运动函数（前进、后退等）。</li>
<li><code>encoder.h</code> &#x2F; <code>encoder.c</code>: 包含编码器初始化、数据读取和速度计算相关的函数。</li>
<li><code>pid_controller.h</code> &#x2F; <code>pid_controller.c</code>: 包含PID数据结构定义、PID初始化和PID计算函数。</li>
<li><code>stm32f1xx_it.c</code>: 中断服务程序文件，可能包含用于编码器速度计算或PID控制循环的定时器中断处理函数。</li>
</ul>
<h3 id="9-3-后续增强建议"><a href="#9-3-后续增强建议" class="headerlink" title="9.3. 后续增强建议"></a>9.3. 后续增强建议</h3><p>本项目为更复杂的机器人应用奠定了坚实的基础。以下是一些可能的后续增强方向：</p>
<ul>
<li><strong>避障功能：</strong> 集成超声波传感器或红外传感器，实现障碍物检测和规避。</li>
<li><strong>循迹功能：</strong> 使用红外反射传感器阵列，使小车能够沿着预设的黑线或白线行驶。</li>
<li><strong>精确转向控制：</strong> 利用编码器反馈，实现基于特定角度或半径的精确转弯 5。</li>
<li><strong>IMU（惯性测量单元）集成：</strong> 加入陀螺仪和加速度计，用于获取小车的姿态信息（俯仰、滚转、偏航），可用于更稳定的运动控制或平衡机器人等应用。</li>
<li><strong>无线遥控：</strong> 通过蓝牙模块（如HC-05&#x2F;06）或Wi-Fi模块（如ESP8266&#x2F;ESP32）实现对小车的远程控制。</li>
<li><strong>SLAM（即时定位与地图构建）：</strong> 对于更高级的自主导航，可以探索SLAM算法的实现（这通常需要更强大的处理器和更复杂的传感器）。</li>
</ul>
<p>通过本项目所学习到的微控制器编程、传感器集成和控制理论知识，具有高度的可迁移性，能够为开发者在机器人技术及相关嵌入式系统领域的深入探索提供有力支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/STM32/GPIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/STM32/GPIO/" class="post-title-link" itemprop="url">GPIO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:19:32" itemprop="dateModified" datetime="2025-05-31T13:19:32+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%94%B5%E6%8E%A7/" itemprop="url" rel="index"><span itemprop="name">RM电控</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">学习记录</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/STM32/%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/STM32/%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">基本设置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:20:34" itemprop="dateModified" datetime="2025-05-31T13:20:34+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%94%B5%E6%8E%A7/" itemprop="url" rel="index"><span itemprop="name">RM电控</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">学习记录</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%94%B5%E6%8E%A7/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/STM32/" itemprop="url" rel="index"><span itemprop="name">STM32</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-开启时钟以及初始化GPIO口"><a href="#1-开启时钟以及初始化GPIO口" class="headerlink" title="1.开启时钟以及初始化GPIO口"></a>1.开启时钟以及初始化GPIO口</h1><hr>
<h2 id="开启时钟"><a href="#开启时钟" class="headerlink" title="开启时钟"></a>开启时钟</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOX,ENABLE);</span><br></pre></td></tr></table></figure>
<p><strong>具体代码解释：</strong><br>	因为GPIO挂载在APB2总线上，所以此函数是用于开启GPIO_x上的时钟信号</p>
<p><strong>参数：</strong><br>	1.<em>RCC_APB2Periph_GPIOx</em><br>		其中，x代表数字，这个参数用于控制开启时钟的GPIO端口号<br>	2.<em>ENABLE</em><br>		这个参数表示开启或关闭时钟，对应<em>ENABLE</em>和<em>DISABLE</em></p>
<hr>
<h2 id="初始化GPIO口"><a href="#初始化GPIO口" class="headerlink" title="初始化GPIO口"></a>初始化GPIO口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_x;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOX,&amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>
<p><strong>具体代码解释：</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">C语言函数作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:25:45" itemprop="dateModified" datetime="2025-05-31T13:25:45+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">RM算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">作业文件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目一：求和"><a href="#题目一：求和" class="headerlink" title="题目一：求和"></a>题目一：求和</h1><h2 id="程序如下："><a href="#程序如下：" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> data[], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sum=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        sum += data[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的for循环即可实现功能</p>
<hr>
<h1 id="题目二：求均方差"><a href="#题目二：求均方差" class="headerlink" title="题目二：求均方差"></a>题目二：求均方差</h1><h2 id="程序如下：-1"><a href="#程序如下：-1" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">Avg</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> data[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> avg=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        avg += data[i];</span><br><span class="line">    <span class="keyword">return</span> avg/N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">StdDev</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> data[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dev=<span class="number">0.0</span>,avg=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        avg += data[i];</span><br><span class="line">    avg /= N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        dev += <span class="built_in">pow</span>(data[i]-avg,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(dev/N,<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="题目三：字符串加密"><a href="#题目三：字符串加密" class="headerlink" title="题目三：字符串加密"></a>题目三：字符串加密</h1><h2 id="程序如下：-2"><a href="#程序如下：-2" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cryptograp</span><span class="params">(<span class="type">char</span> ch[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(ch[i]))</span><br><span class="line">            ch[i] = (ch[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">5</span>)%<span class="number">26</span>+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(ch[i]))</span><br><span class="line">            ch[i] = (ch[i]-<span class="string">&#x27;A&#x27;</span>+<span class="number">5</span>)%<span class="number">26</span>+<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于循环队列的操作方式</p>
<hr>
<h1 id="题目四：万年历"><a href="#题目四：万年历" class="headerlink" title="题目四：万年历"></a>题目四：万年历</h1><h2 id="程序如下：-3"><a href="#程序如下：-3" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowDate</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> daysInMonth = GetDaysofMonth(y, m);</span><br><span class="line">	<span class="type">int</span> firstDay = GetFirstDayInTable(y, m); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***********************************\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Sun Mon Tue Wen Thur Fri Sta\n&quot;</span>); </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; firstDay; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> day = <span class="number">1</span>; day &lt;= daysInMonth; day++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%2d &quot;</span>, day);</span><br><span class="line">		<span class="keyword">if</span> ((day + firstDay) % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n***********************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">C语言指针作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:27:34" itemprop="dateModified" datetime="2025-05-31T13:27:34+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">RM算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">作业文件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h1 id="题目一：输出Hello"><a href="#题目一：输出Hello" class="headerlink" title="题目一：输出Hello"></a>题目一：输出Hello</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="type">char</span> * p;</span><br><span class="line">	<span class="keyword">for</span>(p=s;*p!=‘\<span class="number">0</span>’;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目二：输出Tesla"><a href="#题目二：输出Tesla" class="headerlink" title="题目二：输出Tesla"></a>题目二：输出Tesla</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * p1, <span class="type">const</span> <span class="type">char</span> * p2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;(p2-p1)&gt;<span class="number">0</span>;p1++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *p1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * s = <span class="string">&quot;Tesla123&quot;</span>;</span><br><span class="line">	Print(s, s+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	Print(s, s+<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目三：ForEach"><a href="#题目三：ForEach" class="headerlink" title="题目三：ForEach"></a>题目三：ForEach</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ForEach</span><span class="params">(<span class="type">void</span> *a, <span class="type">int</span> width, <span class="type">int</span> num, <span class="type">void</span> (*f)(<span class="type">void</span> *))</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		f((<span class="type">char</span>*)a + width * i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintSquare</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *q = (<span class="type">int</span>*)p;</span><br><span class="line">	<span class="type">int</span> n = *q;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, n * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintChar</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *q = (<span class="type">char</span>*)p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c,&quot;</span>, *q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">	ForEach(a, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="type">int</span>),PrintSquare);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	ForEach(s, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(s), PrintChar);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目四：Memcpy-1"><a href="#题目四：Memcpy-1" class="headerlink" title="题目四：Memcpy-1"></a>题目四：Memcpy-1</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Memcpy</span><span class="params">(<span class="type">char</span> *src, <span class="type">char</span> *dest, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dest[i] = src[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Strlen</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; s[i]; ++i);</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> s1[<span class="number">30</span>];</span><br><span class="line">	<span class="type">char</span> s2[<span class="number">30</span>];</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">		<span class="type">int</span> b = <span class="number">99999999</span>;</span><br><span class="line">		Memcpy((<span class="type">char</span>*)&amp;a, (<span class="type">char</span>*)&amp;b, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line">		Memcpy(s1, s2, Strlen(s1));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目五：double"><a href="#题目五：double" class="headerlink" title="题目五：double"></a>题目五：double</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Double</span><span class="params">(<span class="type">int</span> * p, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	p[i] *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">	Double(a[<span class="number">1</span>],<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, a[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目六：Memcpy-2"><a href="#题目六：Memcpy-2" class="headerlink" title="题目六：Memcpy-2"></a>题目六：Memcpy-2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Memcpy</span><span class="params">(<span class="type">void</span> *src, <span class="type">void</span> *dest, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *csrc = *src;</span><br><span class="line">	<span class="type">char</span> *cdest = *dest;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cdest[i] = csrc[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[i]);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; size - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	Memcpy(a, b, <span class="keyword">sizeof</span>(a));</span><br><span class="line">	Print(b, n);</span><br><span class="line">	<span class="type">int</span> c[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">	Memcpy(c, c + <span class="number">5</span>, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 将c的前一半拷贝到后一半</span></span><br><span class="line">	Print(c, <span class="number">10</span>);</span><br><span class="line">	<span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">	Memcpy(s + <span class="number">2</span>, s + <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 将s[2]开始的5个字符拷贝到s[4]开始的地方</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">	<span class="type">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">	Memcpy(s1 + <span class="number">5</span>, s1 + <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// 将s1[5]开始的4个字符拷贝到s1[1]开始的地方</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目七：MyMax"><a href="#题目七：MyMax" class="headerlink" title="题目七：MyMax"></a>题目七：MyMax</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* TODO */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare1</span><span class="params">(<span class="type">void</span> * n1, <span class="type">void</span> * n2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p1 = (<span class="type">int</span> * )n1;</span><br><span class="line">	<span class="type">int</span> * p2 = (<span class="type">int</span> * )n2;</span><br><span class="line">	<span class="keyword">return</span> ((*p1)%<span class="number">10</span>) - ((*p2)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare2</span><span class="params">(<span class="type">void</span> * n1, <span class="type">void</span> * n2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p1 = (<span class="type">int</span> * )n1;</span><br><span class="line">	<span class="type">int</span> * p2 = (<span class="type">int</span> * )n2;</span><br><span class="line">	<span class="keyword">return</span> *p1 - *p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Compare3</span><span class="params">(<span class="type">void</span> * n1, <span class="type">void</span> * n2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> * p1 = (<span class="type">float</span> * )n1;<span class="type">float</span> * p2 = (<span class="type">float</span> * )n2;</span><br><span class="line">	<span class="keyword">if</span>( * p1 - * p2 &gt; eps)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(* p2 - * p1 &gt; eps)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MyMax函数，根据比较函数找到数组中的最大元素</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">MyMax</span><span class="params">(<span class="type">void</span> *<span class="built_in">array</span>, <span class="type">size_t</span> size,<span class="type">int</span> n, <span class="type">int</span> (*compare)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *max_element = <span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (compare((<span class="type">char</span> *)<span class="built_in">array</span> + i * size, max_element) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			max_element = (<span class="type">char</span> *)<span class="built_in">array</span> + i * size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max_element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">		<span class="type">float</span> d[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;d[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> * p = (<span class="type">int</span> *)MyMax(a, <span class="keyword">sizeof</span>(<span class="type">int</span>), n, Compare1);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">		p = (<span class="type">int</span> *)MyMax(a, <span class="keyword">sizeof</span>(<span class="type">int</span>), n, Compare2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line">		<span class="type">float</span> * pd = (<span class="type">float</span> *)MyMax(d, <span class="keyword">sizeof</span>(<span class="type">float</span>), n, Compare3);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, *pd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="这段代码找不到任何缺漏的地方，感觉这个-TODO-更像是一个注释什么的"><a href="#这段代码找不到任何缺漏的地方，感觉这个-TODO-更像是一个注释什么的" class="headerlink" title="这段代码找不到任何缺漏的地方，感觉这个&#x2F;TODO&#x2F;更像是一个注释什么的"></a>这段代码找不到任何缺漏的地方，感觉这个&#x2F;<em>TODO</em>&#x2F;更像是一个注释什么的</h5><h5 id="硬要说不足的地方，就是三个Compare函数中参数应该带const，整个函数的功能性并没有缺失"><a href="#硬要说不足的地方，就是三个Compare函数中参数应该带const，整个函数的功能性并没有缺失" class="headerlink" title="硬要说不足的地方，就是三个Compare函数中参数应该带const，整个函数的功能性并没有缺失"></a>硬要说不足的地方，就是三个Compare函数中参数应该带const，整个函数的功能性并没有缺失</h5><hr>
<h1 id="题目八：指向指针的指针"><a href="#题目八：指向指针的指针" class="headerlink" title="题目八：指向指针的指针"></a>题目八：指向指针的指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	x = <span class="number">10</span>;</span><br><span class="line">	y = <span class="number">20</span>;</span><br><span class="line">	z = <span class="number">30</span>;</span><br><span class="line">	<span class="type">int</span> * a[<span class="number">3</span>] = &#123;&amp;x, &amp;y, &amp;z&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> **p=a; p &lt; a + <span class="number">3</span>; ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目九：SwapMemory"><a href="#题目九：SwapMemory" class="headerlink" title="题目九：SwapMemory"></a>题目九：SwapMemory</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SwapMemory</span><span class="params">(<span class="type">void</span> * m1, <span class="type">void</span> * m2, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> temp;</span><br><span class="line">	<span class="type">char</span> *cm1 = (<span class="type">char</span> *)m1;</span><br><span class="line">	<span class="type">char</span> *cm2 = (<span class="type">char</span> *)m2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = cm1[i];</span><br><span class="line">		cm1[i] = cm2[i];</span><br><span class="line">		cm2[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintIntArray</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="type">int</span> b[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">	SwapMemory(a, b, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	PrintIntArray(a, <span class="number">5</span>);</span><br><span class="line">	PrintIntArray(b, <span class="number">5</span>);</span><br><span class="line">	<span class="type">char</span> s1[] = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">	<span class="type">char</span> s2[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	SwapMemory(s1, s2, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">循环与判断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:28:21" itemprop="dateModified" datetime="2025-05-31T13:28:21+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">RM算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">作业文件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h1 id="题目一：将三个整数从大到小输出"><a href="#题目一：将三个整数从大到小输出" class="headerlink" title="题目一：将三个整数从大到小输出"></a>题目一：将三个整数从大到小输出<br></h1><h2 id="程序如下："><a href="#程序如下：" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">	<span class="keyword">if</span> (a&lt;(b&lt;c?b:c))<span class="comment">//a是最小值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,(b&gt;c?b:c),(b&gt;c?c:b),a);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a&gt;(b&gt;c?b:c))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,(b&gt;c?b:c),(b&gt;c?c:b));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,(b&gt;c?b:c),a,(b&gt;c?c:b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用三元表达式替换了一下if else语句<del>（单纯懒得写而已）</del></p>
<hr>
<h1 id="题目2：判断100-200的素数，并输出所有素数"><a href="#题目2：判断100-200的素数，并输出所有素数" class="headerlink" title="题目2：判断100-200的素数，并输出所有素数"></a>题目2：判断100-200的素数，并输出所有素数</h1><h2 id="程序如下：-1"><a href="#程序如下：-1" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N=<span class="number">200</span>,i,flag,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">100</span>;i &lt;= N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)<span class="built_in">sqrt</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%k == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,i);</span><br><span class="line">            count +=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了美观，八个为一行输出<br>（其实判断是否为素数完全可以写成一个函数，这样主程序就不会这么臃肿）</p>
<hr>
<h1 id="题目3：输入一个正整数，将其分解质因数"><a href="#题目3：输入一个正整数，将其分解质因数" class="headerlink" title="题目3：输入一个正整数，将其分解质因数"></a>题目3：输入一个正整数，将其分解质因数</h1><h2 id="程序如下：-2"><a href="#程序如下：-2" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isprime</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    N = n;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (N % i == <span class="number">0</span> &amp;&amp; isprime(i))</span><br><span class="line">        &#123;</span><br><span class="line">            N /= i;</span><br><span class="line">            a[p++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; p; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;p<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*&quot;</span>, a[j]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isprime</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(n); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上一题说的这题实现了：）</p>
<p>Date: 24.12.1</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">C语言数据类型编程题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:26:38" itemprop="dateModified" datetime="2025-05-31T13:26:38+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">RM算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">作业文件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h1 id="题目一：输出对应的数据类型"><a href="#题目一：输出对应的数据类型" class="headerlink" title="题目一：输出对应的数据类型"></a>题目一：输出对应的数据类型<br></h1><h2 id="程序如下："><a href="#程序如下：" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">    fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);</span><br><span class="line">    input[<span class="built_in">strcspn</span>(input, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(input) == <span class="number">1</span> &amp;&amp; <span class="built_in">isprint</span>(input[<span class="number">0</span>]))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data type: char, ASCII value: %d\n&quot;</span>, (<span class="type">int</span>)input[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *endptr;</span><br><span class="line">        <span class="type">long</span> intValue = strtol(input, &amp;endptr, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (endptr != input &amp;&amp; *endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Data type: int\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> floatValue = strtof(input, &amp;endptr);</span><br><span class="line">            <span class="keyword">if</span> (endptr != input &amp;&amp; *endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data type: float\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> doubleValue = strtod(input, &amp;endptr);</span><br><span class="line">                <span class="keyword">if</span> (endptr != input &amp;&amp; *endptr == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Data type: double\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于C语言把char类型视为特殊的int来处理，所以上述代码只能区分int，char和float。<br>对于数字的char类型（例如字符‘1’），以及double和float并不能很好地区分开来（目前也是没有想到什么好办法）</p>
<hr>
<h1 id="题目二：显示身高"><a href="#题目二：显示身高" class="headerlink" title="题目二：显示身高"></a>题目二：显示身高</h1><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCH 2.54</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入身高（英尺）：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;height);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3f&quot;</span>,INCH*height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题目三：舍罕王的失算"><a href="#题目三：舍罕王的失算" class="headerlink" title="题目三：舍罕王的失算"></a>题目三：舍罕王的失算</h1><h2 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEED 25000.0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">        sum += <span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf Kg&quot;</span>,sum/SEED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法效率最高的估计就是循环了，递归写法稍微简单一点但是空间复杂度会很大</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">C语言数组作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:27:15" itemprop="dateModified" datetime="2025-05-31T13:27:15+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">RM算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">作业文件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h1 id="题目一：计算总和"><a href="#题目一：计算总和" class="headerlink" title="题目一：计算总和"></a>题目一：计算总和</h1><h2 id="程序如下："><a href="#程序如下：" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">        sum += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="题目二：反转字符串"><a href="#题目二：反转字符串" class="headerlink" title="题目二：反转字符串"></a>题目二：反转字符串</h1><h2 id="程序如下：-1"><a href="#程序如下：-1" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">99</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[len-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="题目三：最大最小元素"><a href="#题目三：最大最小元素" class="headerlink" title="题目三：最大最小元素"></a>题目三：最大最小元素</h1><h2 id="程序如下：-2"><a href="#程序如下：-2" class="headerlink" title="程序如下："></a>程序如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,max;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> num[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">    <span class="type">int</span> min=max=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]&gt;max)</span><br><span class="line">            max = num[i];</span><br><span class="line">        <span class="keyword">if</span> (num[i]&lt;min)</span><br><span class="line">            min = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=%d,max=%d&quot;</span>,min,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/01/RM__PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">环境配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:28:05" itemprop="dateModified" datetime="2025-05-31T13:28:05+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/" itemprop="url" rel="index"><span itemprop="name">RM_PRIME</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">RM算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">作业文件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RM-PRIME/RM%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A%E6%96%87%E4%BB%B6/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h1 id="1-目前使用的编译器"><a href="#1-目前使用的编译器" class="headerlink" title="1.目前使用的编译器"></a>1.目前使用的编译器</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python<br></h2><p>用原生的<em>IDLE</em>,主要是方便<del>（懒）</del></p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言<br></h2><p>因为<em>VScode</em>并不内置编译器或集成开发环境，<br>所以使用的是<em><strong>MinGW-w64</strong></em>(也就是<em><strong>GCC</strong></em>的<em>windows</em>版本)<br></p>
<hr>
<h1 id="2-之前用的软件"><a href="#2-之前用的软件" class="headerlink" title="2.之前用的软件"></a>2.之前用的软件<br></h1><p><em><strong>Code::Blocks</strong></em>，基本就是C语言入门标配，然后就是VScode了</p>
<p>至于Python的话，<em><strong>Anaconda</strong></em>转<em><strong>Spyder</strong></em>最后回归<em><strong>IDLE</strong></em></p>
<hr>
<h1 id="3编译并测试代码"><a href="#3编译并测试代码" class="headerlink" title="3编译并测试代码"></a>3编译并测试代码</h1><p>编译基本没什么问题，Linux下的环境搭建和编译测试明显优于windows下的VScode<br>两个系统下运行代码都没有问题</p>
<p>「此处为Linux下运行测试的图片」<br>![[Linux-VScode-test.png]]<br>如果看不见的话就是同一个目录下的那张</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="St_w"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">St_w</p>
  <div class="site-description" itemprop="description">老大，欢迎回来喵~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Fri May 30 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">St_w</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共74.2k字</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  











<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

    </div>
</body>
</html>
