<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="title: 电机驱动date: 2025-01-01 18:00:00tags:  - STM32  - 人人卓越categories:  - 杂物基于STM32F103C8T6的机器人小车电机驱动与PID控制设计第1节：STM32F103C8T6与机器人小车电机控制概述1.1. STM32F103C8T6微控制器概览STM32F103C8T6是一款基于ARM Cortex-M3内核的32位微">
<meta property="og:type" content="article">
<meta property="og:title" content="Stellato的星空">
<meta property="og:url" content="http://example.com/2025/05/30/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="Stellato的星空">
<meta property="og:description" content="title: 电机驱动date: 2025-01-01 18:00:00tags:  - STM32  - 人人卓越categories:  - 杂物基于STM32F103C8T6的机器人小车电机驱动与PID控制设计第1节：STM32F103C8T6与机器人小车电机控制概述1.1. STM32F103C8T6微控制器概览STM32F103C8T6是一款基于ARM Cortex-M3内核的32位微">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-05-30T12:49:58.131Z">
<meta property="article:modified_time" content="2025-05-31T04:46:02.923Z">
<meta property="article:author" content="St_w">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/05/30/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Stellato的星空</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stellato的星空</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/30/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-30 20:49:58" itemprop="dateCreated datePublished" datetime="2025-05-30T20:49:58+08:00">2025-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 12:46:02" itemprop="dateModified" datetime="2025-05-31T12:46:02+08:00">2025-05-31</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h2 id="title-电机驱动date-2025-01-01-18-00-00tags-STM32-人人卓越categories-杂物"><a href="#title-电机驱动date-2025-01-01-18-00-00tags-STM32-人人卓越categories-杂物" class="headerlink" title="title: 电机驱动date: 2025-01-01 18:00:00tags:  - STM32  - 人人卓越categories:  - 杂物"></a>title: 电机驱动<br>date: 2025-01-01 18:00:00<br>tags:<br>  - STM32<br>  - 人人卓越<br>categories:<br>  - 杂物</h2><h1 id="基于STM32F103C8T6的机器人小车电机驱动与PID控制设计"><a href="#基于STM32F103C8T6的机器人小车电机驱动与PID控制设计" class="headerlink" title="基于STM32F103C8T6的机器人小车电机驱动与PID控制设计"></a>基于STM32F103C8T6的机器人小车电机驱动与PID控制设计</h1><h2 id="第1节：STM32F103C8T6与机器人小车电机控制概述"><a href="#第1节：STM32F103C8T6与机器人小车电机控制概述" class="headerlink" title="第1节：STM32F103C8T6与机器人小车电机控制概述"></a>第1节：STM32F103C8T6与机器人小车电机控制概述</h2><h3 id="1-1-STM32F103C8T6微控制器概览"><a href="#1-1-STM32F103C8T6微控制器概览" class="headerlink" title="1.1. STM32F103C8T6微控制器概览"></a>1.1. STM32F103C8T6微控制器概览</h3><p>STM32F103C8T6是一款基于ARM Cortex-M3内核的32位微控制器，由意法半导体（STMicroelectronics）生产。其核心特性包括高达72 MHz的工作频率、64KB的Flash程序存储器和20KB的SRAM 1。这些特性使其成为各种嵌入式控制应用的理想选择，尤其是在机器人技术领域。</p>
<p>对于电机控制而言，STM32F103C8T6的以下外设至关重要：</p>
<ul>
<li><strong>通用输入&#x2F;输出（GPIO）引脚：</strong> 该微控制器提供多达37个I&#x2F;O引脚 1，可用于配置电机驱动器的方向控制信号，并与其他传感器或模块进行通信。</li>
<li><strong>定时器（TIM）：</strong> STM32F103C8T6内置多个通用定时器（如TIM1、TIM2、TIM3、TIM4）和高级控制定时器（部分型号）。这些定时器能够产生脉冲宽度调制（PWM）信号，这是控制直流电机速度的关键技术 1。此外，定时器还可以配置为编码器接口模式，用于读取电机转速和位置信息，这对于实现闭环控制（如PID）至关重要。</li>
</ul>
<p>尽管STM32F103C8T6被归类为“中等密度”设备 1，但其提供的外设组合对于控制一个双电机机器人小车来说已经绰绰有余，即使是包含PID算法和编码器反馈的复杂控制系统。其72MHz的最高主频确保了控制回路能够及时执行，满足实时性要求。</p>
<h3 id="1-2-差速驱动机器人小车"><a href="#1-2-差速驱动机器人小车" class="headerlink" title="1.2. 差速驱动机器人小车"></a>1.2. 差速驱动机器人小车</h3><p>差速驱动是一种常见的机器人移动平台设计，它通过独立驱动位于共同轴线上的两个轮子来实现运动和转向 5。其基本运动方式如下：</p>
<ul>
<li><strong>前进&#x2F;后退：</strong> 两个轮子以相同的速度和相同的方向旋转。</li>
<li><strong>转向（原地旋转&#x2F;曲线转向）：</strong> 两个轮子以不同的速度旋转，或者以相反的方向旋转。例如，要使小车左转，可以使右轮转速高于左轮，或者使左轮反转而右轮正转 6。</li>
</ul>
<p>差速驱动的优势在于其机械结构简单，控制相对直接。</p>
<h3 id="1-3-电机驱动器的作用"><a href="#1-3-电机驱动器的作用" class="headerlink" title="1.3. 电机驱动器的作用"></a>1.3. 电机驱动器的作用</h3><p>微控制器（MCU）的GPIO引脚通常无法直接驱动直流电机，因为电机所需的电流和电压超出了MCU引脚的承受能力。因此，电机驱动器扮演了至关重要的角色。</p>
<p>H桥电路是电机驱动器的核心技术，它允许通过切换电路中晶体管的导通状态来改变流过电机电流的方向，从而实现电机的双向控制 7。电机驱动器将来自MCU的低功率控制信号（如方向信号和PWM信号）转换为驱动电机所需的高功率信号。这种分离不仅保护了MCU免受电机大电流的冲击，还确保了电机能够获得稳定高效的能量供应。在后续章节中，将详细介绍具体的电机驱动器IC。</p>
<h2 id="第2节：硬件搭建与注意事项"><a href="#第2节：硬件搭建与注意事项" class="headerlink" title="第2节：硬件搭建与注意事项"></a>第2节：硬件搭建与注意事项</h2><h3 id="2-1-选择电机驱动器IC"><a href="#2-1-选择电机驱动器IC" class="headerlink" title="2.1. 选择电机驱动器IC"></a>2.1. 选择电机驱动器IC</h3><p>为本项目选择合适的电机驱动器IC至关重要。市面上有多种选择，其中L298N和DRV8833是两种常见的适用于此项目的双H桥电机驱动器。</p>
<h4 id="2-1-1-L298N双H桥电机驱动器"><a href="#2-1-1-L298N双H桥电机驱动器" class="headerlink" title="2.1.1. L298N双H桥电机驱动器"></a>2.1.1. L298N双H桥电机驱动器</h4><ul>
<li><strong>描述：</strong> L298N是一款坚固耐用、广泛应用的双H桥电机驱动器，能够独立驱动两个直流电机。它支持较宽的电压范围（最高可达35V-46V）和较大的电流（每通道最高2A）9。</li>
<li><strong>控制逻辑：</strong> 通常，每个电机需要2个输入引脚（如IN1, IN2）来控制方向，以及1个使能引脚（如ENA）通过PWM信号来控制速度 9。参考资料14中的表5清晰地展示了其真值表。</li>
<li><strong>注意事项：</strong> L298N内部晶体管导通时存在约2V的电压降 12，这会导致效率较低，并可能需要比电机额定电压更高的供电电压。在大电流工作时，通常需要加装散热片 12。许多L298N模块集成了板载5V稳压器 8。</li>
</ul>
<h4 id="2-1-2-DRV8833双H桥电机驱动器"><a href="#2-1-2-DRV8833双H桥电机驱动器" class="headerlink" title="2.1.2. DRV8833双H桥电机驱动器"></a>2.1.2. DRV8833双H桥电机驱动器</h4><ul>
<li><strong>描述：</strong> DRV8833是一款更现代、效率更高的电机驱动器，主要得益于其内部集成的低导通电阻（Rds(on)）MOSFET 15。其工作电压范围较低（2.7V - 10.8V），适用于驱动功率较小的电机（每通道RMS电流可达1.5A）15。</li>
<li><strong>控制逻辑：</strong> 与L298N类似，每个H桥也使用2个输入引脚（如xIN1, xIN2）进行方向和速度控制（PWM信号可施加于这些输入引脚）15。参考资料15中的表2详细说明了其控制模式。</li>
<li><strong>特性：</strong> DRV8833通常包含故障检测（nFAULT）和低功耗睡眠模式（nSLEEP）等额外功能 15。</li>
</ul>
<h4 id="2-1-3-比较与推荐"><a href="#2-1-3-比较与推荐" class="headerlink" title="2.1.3. 比较与推荐"></a>2.1.3. 比较与推荐</h4><p>为了帮助用户根据具体需求做出选择，下表对L298N和DRV8833的关键特性进行了比较：</p>
<p><strong>表1：L298N与DRV8833电机驱动器比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>特性</strong></td>
<td><strong>L298N</strong></td>
<td><strong>DRV8833</strong></td>
</tr>
<tr>
<td>工作电压范围</td>
<td>5V - 35V (典型模块, IC本身可达46V 10)</td>
<td>2.7V - 10.8V 15</td>
</tr>
<tr>
<td>每通道最大电流</td>
<td>2A (峰值3A) 11</td>
<td>1.5A RMS, 2A 峰值 15</td>
</tr>
<tr>
<td>效率 (电压降&#x2F;Rds(on))</td>
<td>较低 (电压降约2V 12)</td>
<td>较高 (HS + LS Rds(on) 约 360 mΩ 15)</td>
</tr>
<tr>
<td>封装尺寸&#x2F;集成度</td>
<td>通常为模块形式，体积较大</td>
<td>IC封装较小，模块也相对紧凑</td>
</tr>
<tr>
<td>散热管理</td>
<td>大电流时通常需要散热片 12</td>
<td>视具体应用而定，通常散热需求较低</td>
</tr>
<tr>
<td>板载5V稳压器</td>
<td>许多模块包含 8</td>
<td>通常不包含</td>
</tr>
<tr>
<td>特殊功能</td>
<td>较少</td>
<td>睡眠模式, 故障检测, 过流&#x2F;过温保护 16</td>
</tr>
<tr>
<td>典型成本&#x2F;易得性</td>
<td>成本较低，非常普及</td>
<td>成本略高，也较易获得</td>
</tr>
</tbody></table>
<p>在本报告中，<strong>将以L298N作为详细示例</strong>，因为它在业余爱好者套件中历史悠久且对初学者而言较为坚固。然而，DRV8833作为一种更高效的选择，尤其适用于电池供电或对体积有要求的紧凑型设计，也将被提及。</p>
<p>电机驱动器的选择对整个系统设计具有连锁反应。L298N的电压降可能意味着需要一个比电机名义电压更高的电池组，这会影响机器人的尺寸、重量和成本。许多L298N模块上的板载5V稳压器 8 在电机供电电压合适（例如，小于等于12V 9）时可以简化MCU的供电，但在更高电压下则可能出现问题。相比之下，DRV8833的较低工作电压范围可能更适合直接使用锂电池供电而无需额外稳压，但同时也限制了电机的选择。其高效率则有利于延长电池续航。</p>
<h3 id="2-2-硬件连接图：STM32F103C8T6与L298N及两路直流电机"><a href="#2-2-硬件连接图：STM32F103C8T6与L298N及两路直流电机" class="headerlink" title="2.2. 硬件连接图：STM32F103C8T6与L298N及两路直流电机"></a>2.2. 硬件连接图：STM32F103C8T6与L298N及两路直流电机</h3><p>以下是STM32F103C8T6与L298N模块及两路直流电机连接的详细说明（具体引脚选择可根据实际情况调整，此处为示例）：</p>
<ul>
<li><strong>方向控制：</strong><ul>
<li>STM32 GPIO (例如 PA0) -&gt; L298N IN1 (左电机方向1)</li>
<li>STM32 GPIO (例如 PA1) -&gt; L298N IN2 (左电机方向2)</li>
<li>STM32 GPIO (例如 PA2) -&gt; L298N IN3 (右电机方向1)</li>
<li>STM32 GPIO (例如 PA3) -&gt; L298N IN4 (右电机方向2)</li>
</ul>
</li>
<li><strong>速度控制 (PWM)：</strong><ul>
<li>STM32 定时器PWM输出引脚 (例如 PB0, TIM3_CH3) -&gt; L298N ENA (左电机使能&#x2F;速度)</li>
<li>STM32 定时器PWM输出引脚 (例如 PB1, TIM3_CH4) -&gt; L298N ENB (右电机使能&#x2F;速度)</li>
</ul>
</li>
<li><strong>电源：</strong><ul>
<li>电机电源 (例如 7.4V - 12V 电池组) -&gt; L298N VS (或标有12V输入的端口) 和 GND</li>
<li>电机 -&gt; L298N OUT1&#x2F;OUT2 (左电机) 和 OUT3&#x2F;OUT4 (右电机)</li>
</ul>
</li>
<li><strong>逻辑电源与共地：</strong><ul>
<li>STM32 GND -&gt; L298N GND (共地连接至关重要 9)</li>
<li>L298N逻辑电源 (VSS或模块上的5V引脚)：<ul>
<li>如果电机电源电压小于等于12V，并且L298N模块上的5V使能跳线帽已连接，则此引脚可输出5V，可用于为STM32供电（需注意电流能力）。</li>
<li>如果电机电源电压大于12V，应移除5V使能跳线帽，并从外部为L298N的5V逻辑输入引脚提供稳定的5V电源（例如，从STM32的5V输出引脚，如果STM32板有的话，或者使用独立的5V稳压器）8。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一个清晰的电路连接图对于正确搭建硬件至关重要，具体图示将在报告的相应部分提供（基于11中的原则）。</p>
<h3 id="2-3-电源注意事项"><a href="#2-3-电源注意事项" class="headerlink" title="2.3. 电源注意事项"></a>2.3. 电源注意事项</h3><ul>
<li>通常建议为MCU和电机使用独立的电源，以提高系统稳定性并防止电机噪声干扰MCU。</li>
<li>电池的选择应基于电机的额定电压和电流需求。</li>
<li>STM32F103C8T6通常需要3.3V的稳定电源。“Blue Pill”等常见的STM32F103C8T6开发板通常带有板载3.3V稳压器。</li>
</ul>
<h3 id="2-4-可选但PID控制推荐-旋转编码器"><a href="#2-4-可选但PID控制推荐-旋转编码器" class="headerlink" title="2.4. (可选但PID控制推荐) 旋转编码器"></a>2.4. (可选但PID控制推荐) 旋转编码器</h3><ul>
<li>旋转编码器是一种反馈设备，用于测量电机的转速和&#x2F;或位置 20。</li>
<li>常见的类型是增量式编码器，它输出A、B两相正交脉冲信号。</li>
<li><strong>接线：</strong> 编码器的A、B相输出连接到STM32的定时器输入引脚（配置为编码器接口模式）或配置为外部中断的GPIO引脚。编码器还需要VCC和GND供电 20。</li>
</ul>
<p>尽早引入编码器的概念，即使用户最初不打算实现PID控制，也能为后续的高级控制打下基础，并强调闭环系统反馈的重要性。</p>
<h2 id="第3节：STM32CubeIDE电机控制配置"><a href="#第3节：STM32CubeIDE电机控制配置" class="headerlink" title="第3节：STM32CubeIDE电机控制配置"></a>第3节：STM32CubeIDE电机控制配置</h2><h3 id="3-1-在STM32CubeIDE中设置新工程"><a href="#3-1-在STM32CubeIDE中设置新工程" class="headerlink" title="3.1. 在STM32CubeIDE中设置新工程"></a>3.1. 在STM32CubeIDE中设置新工程</h3><p>STM32CubeIDE是一款集成了STM32CubeMX图形化配置工具的集成开发环境。创建一个新工程的步骤通常包括选择目标MCU型号（STM32F103C8T6），然后利用STM32CubeMX进行引脚和外设的配置 7。</p>
<h3 id="3-2-系统时钟配置"><a href="#3-2-系统时钟配置" class="headerlink" title="3.2. 系统时钟配置"></a>3.2. 系统时钟配置</h3><p>系统时钟（SYSCLK）是MCU执行指令和外设工作的核心。对于STM32F103C8T6，通常将其配置为最大频率72MHz。如果开发板上装有外部高速晶振（HSE），例如“Blue Pill”板上常见的8MHz晶振 24，则应优先使用HSE作为时钟源，并通过PLL倍频到72MHz。同时，需要确保APB1和APB2总线上的外设时钟（PCLK1, PCLK2）也得到正确配置，因为定时器等外设挂载在这些总线上，其工作频率与总线时钟相关 7。</p>
<h3 id="3-3-L298N方向控制的GPIO配置"><a href="#3-3-L298N方向控制的GPIO配置" class="headerlink" title="3.3. L298N方向控制的GPIO配置"></a>3.3. L298N方向控制的GPIO配置</h3><p>为L298N的IN1、IN2、IN3、IN4引脚选择四个STM32F103C8T6的GPIO引脚（例如PA0, PA1, PA2, PA3）。在STM32CubeMX中，将这些引脚配置为“GPIO_Output”模式 7。可以设置初始输出电平（例如，低电平），输出速度。对于推挽输出模式，通常不需要配置上拉或下拉电阻。如果需要更深入地理解GPIO寄存器级别的配置，可以参考STM32参考手册中关于GPIOx_CRL和GPIOx_CRH寄存器的说明 4，但STM32 HAL库对这些底层细节进行了抽象。</p>
<h3 id="3-4-PWM速度控制的定时器配置"><a href="#3-4-PWM速度控制的定时器配置" class="headerlink" title="3.4. PWM速度控制的定时器配置"></a>3.4. PWM速度控制的定时器配置</h3><p>选择STM32F103C8T6上的两个定时器通道用于产生PWM信号，以控制L298N的ENA和ENB引脚（例如，TIM2的通道1和通道2，或者不同定时器的通道，如TIM1的通道1和TIM2的通道1）。所选的GPIO引脚必须是相应定时器通道的PWM输出复用功能引脚 1。</p>
<p>在STM32CubeMX中进行如下配置 4：</p>
<ol>
<li><strong>选择并使能定时器：</strong> 例如，选择TIM2。</li>
<li><strong>设置时钟源：</strong> 选择“Internal Clock”。</li>
<li><strong>配置通道为PWM输出模式：</strong> 例如，将Channel 1和Channel 2配置为“PWM Generation CH1”和“PWM Generation CH2”。</li>
<li><strong>参数设置：</strong><ul>
<li><strong>预分频器 (Prescaler, PSC)：</strong> 用于降低定时器的计数时钟频率。计数器时钟频率 fCK_CNT​ 的计算公式为：fCK_CNT​&#x3D;fAPB_Timer​&#x2F;(PSC+1)，其中 fAPB_Timer​ 是定时器所在的APB总线时钟频率。</li>
<li><strong>计数模式 (Counter Mode)：</strong> 对于PWM生成，通常选择向上计数模式。</li>
<li><strong>计数周期 (Counter Period, Auto-Reload Register - ARR)：</strong> 定义PWM信号的周期，从而决定PWM频率。PWM频率 fPWM​ 的计算公式为：fPWM​&#x3D;fCK_CNT​&#x2F;(ARR+1)。</li>
<li><strong>脉冲宽度 (Pulse, Capture Compare Register - CCRx)：</strong> 定义PWM信号的占空比。占空比 DutyCycle 的计算公式为：DutyCycle&#x3D;(CCRx&#x2F;(ARR+1))×100%。</li>
<li><strong>PWM模式 (PWM Mode)：</strong> 通常选择“PWM Mode 1”或“PWM Mode 2”。<ul>
<li>PWM Mode 1：当 TIMx_CNT&lt;TIMx_CCRx 时，输出有效电平（例如高电平）。</li>
<li>PWM Mode 2：当 TIMx_CNT&gt;TIMx_CCRx 时，输出有效电平（例如高电平）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>PWM频率和分辨率的考量：</p>
<p>PWM频率的选择并非随意。较高的频率可以使电机运行更平稳，减少可闻噪音，但也可能增加电机驱动器的开关损耗。较低的频率可能对电机本身的效率不利。对于L298N，1kHz至20kHz范围内的频率较为常见，例如9中提到了1.5kHz。这是一个需要权衡的参数。PSC和ARR的组合不仅决定PWM频率，也影响PWM的分辨率。较大的ARR值可以提供更精细的占空比控制。</p>
<p>示例计算：</p>
<p>假设APB1定时器时钟为72MHz（假设HCLK未分频直接供给APB1总线上的定时器）。</p>
<p>期望PWM频率为10kHz。</p>
<ul>
<li>方案一：设置PSC &#x3D; 0，则 fCK_CNT​&#x3D;72MHz。此时，ARR&#x3D;(72MHz&#x2F;10kHz)−1&#x3D;7200−1&#x3D;7199。</li>
<li>方案二：设置PSC &#x3D; 71，则 fCK_CNT​&#x3D;72MHz&#x2F;(71+1)&#x3D;1MHz。此时，ARR&#x3D;(1MHz&#x2F;10kHz)−1&#x3D;100−1&#x3D;99。 方案一具有更高的分辨率。</li>
</ul>
<p>完成配置后，从STM32CubeMX生成初始化代码。</p>
<h3 id="3-5-表2：STM32F103C8T6与L298N控制引脚映射示例"><a href="#3-5-表2：STM32F103C8T6与L298N控制引脚映射示例" class="headerlink" title="3.5. 表2：STM32F103C8T6与L298N控制引脚映射示例"></a>3.5. 表2：STM32F103C8T6与L298N控制引脚映射示例</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>STM32 引脚</strong></td>
<td><strong>STM32 功能</strong></td>
<td><strong>L298N 引脚</strong></td>
<td><strong>用途</strong></td>
</tr>
<tr>
<td>PA0</td>
<td>GPIO_Output</td>
<td>IN1</td>
<td>左电机方向控制1</td>
</tr>
<tr>
<td>PA1</td>
<td>GPIO_Output</td>
<td>IN2</td>
<td>左电机方向控制2</td>
</tr>
<tr>
<td>PA2</td>
<td>GPIO_Output</td>
<td>IN3</td>
<td>右电机方向控制1</td>
</tr>
<tr>
<td>PA3</td>
<td>GPIO_Output</td>
<td>IN4</td>
<td>右电机方向控制2</td>
</tr>
<tr>
<td>PB0</td>
<td>TIM3_CH3 (PWM)</td>
<td>ENA</td>
<td>左电机速度控制</td>
</tr>
<tr>
<td>PB1</td>
<td>TIM3_CH4 (PWM)</td>
<td>ENB</td>
<td>右电机速度控制</td>
</tr>
<tr>
<td>3.3V</td>
<td>-</td>
<td>(可选，若L298N模块需要外部5V逻辑供电且STM32有5V输出，则连接至L298N的5V输入，否则L298N的5V由其板载稳压器提供或外部独立5V供电)</td>
<td>L298N逻辑电源</td>
</tr>
<tr>
<td>GND</td>
<td>-</td>
<td>GND</td>
<td>电源地</td>
</tr>
</tbody></table>
<p>此表提供了一个清晰的参考，帮助用户正确连接硬件，并理解MCU各引脚在软件中的角色，从而将软件配置与物理接线联系起来。</p>
<h2 id="第4节：实现机器人小车基本运动-C代码与HAL库"><a href="#第4节：实现机器人小车基本运动-C代码与HAL库" class="headerlink" title="第4节：实现机器人小车基本运动 (C代码与HAL库)"></a>第4节：实现机器人小车基本运动 (C代码与HAL库)</h2><h3 id="4-1-工程结构与HAL初始化"><a href="#4-1-工程结构与HAL初始化" class="headerlink" title="4.1. 工程结构与HAL初始化"></a>4.1. 工程结构与HAL初始化</h3><p>由STM32CubeIDE生成的<code>main.c</code>文件包含了程序的主体结构。在<code>main()</code>函数中，首先会调用<code>HAL_Init()</code>进行HAL库的初始化，接着调用<code>SystemClock_Config()</code>配置系统时钟。之后，由STM32CubeMX生成的GPIO和定时器初始化函数（如<code>MX_GPIO_Init()</code>和<code>MX_TIMx_Init()</code>）也会被调用。</p>
<h3 id="4-2-启动PWM信号"><a href="#4-2-启动PWM信号" class="headerlink" title="4.2. 启动PWM信号"></a>4.2. 启动PWM信号</h3><p>为了使能L298N的速度控制引脚ENA和ENB，需要在相应的定时器初始化之后启动PWM信号。这通过为每个PWM通道调用<code>HAL_TIM_PWM_Start()</code>函数来实现 7。此操作通常在初始化阶段执行一次。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设htim3用于PWM输出，通道3和4分别控制左电机和右电机</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3); <span class="comment">// 启动左电机PWM</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4); <span class="comment">// 启动右电机PWM</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-定义电机和方向类型-示例"><a href="#4-3-定义电机和方向类型-示例" class="headerlink" title="4.3. 定义电机和方向类型 (示例)"></a>4.3. 定义电机和方向类型 (示例)</h3><p>为了提高代码的可读性和可维护性，建议使用<code>typedef enum</code>来定义电机和方向的类型：</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MOTOR_LEFT,</span><br><span class="line">    MOTOR_RIGHT</span><br><span class="line">&#125; Motor_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DIR_FORWARD,</span><br><span class="line">    DIR_BACKWARD,</span><br><span class="line">    DIR_STOP <span class="comment">// 电机停止（通过方向控制引脚）</span></span><br><span class="line">&#125; Direction_TypeDef;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-底层电机控制函数"><a href="#4-4-底层电机控制函数" class="headerlink" title="4.4. 底层电机控制函数"></a>4.4. 底层电机控制函数</h3><h4 id="4-4-1-设置电机PWM速度函数"><a href="#4-4-1-设置电机PWM速度函数" class="headerlink" title="4.4.1. 设置电机PWM速度函数"></a>4.4.1. 设置电机PWM速度函数</h4><p>此函数用于设置指定电机PWM信号的占空比，从而控制电机转速。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  设置电机PWM速度</span></span><br><span class="line"><span class="comment">  * @param  htimx: 定时器句柄指针 (例如 &amp;htim3)</span></span><br><span class="line"><span class="comment">  * @param  TIM_CHANNEL_y: 定时器通道 (例如 TIM_CHANNEL_3)</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_motor_pwm_speed</span><span class="params">(TIM_HandleTypeDef *htimx, <span class="type">uint32_t</span> TIM_CHANNEL_y, <span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> raw_pwm;</span><br><span class="line">    <span class="keyword">if</span> (speed_percentage &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        speed_percentage = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据ARR值计算CCRx的原始值</span></span><br><span class="line">    raw_pwm = (<span class="type">uint16_t</span>)(((<span class="type">float</span>)speed_percentage / <span class="number">100.0f</span>) * htimx-&gt;Instance-&gt;ARR);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(htimx, TIM_CHANNEL_y, raw_pwm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数接收定时器句柄、定时器通道和期望的速度百分比作为参数。它首先将速度百分比转换为对应定时器ARR（自动重载寄存器）值的原始PWM比较值（CCRx），然后使用<code>__HAL_TIM_SET_COMPARE()</code>宏函数来更新PWM的占空比 25。</p>
<h4 id="4-4-2-L298N电机方向控制函数"><a href="#4-4-2-L298N电机方向控制函数" class="headerlink" title="4.4.2. L298N电机方向控制函数"></a>4.4.2. L298N电机方向控制函数</h4><p>此函数根据L298N的控制逻辑，通过设置相应的GPIO引脚电平来控制电机方向。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已在CubeMX中为方向引脚定义了宏，例如:</span></span><br><span class="line"><span class="comment">// #define L_IN1_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define L_IN1_Pin GPIO_PIN_0</span></span><br><span class="line"><span class="comment">// #define L_IN2_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define L_IN2_Pin GPIO_PIN_1</span></span><br><span class="line"><span class="comment">// #define R_IN3_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define R_IN3_Pin GPIO_PIN_2</span></span><br><span class="line"><span class="comment">// #define R_IN4_GPIO_Port GPIOA</span></span><br><span class="line"><span class="comment">// #define R_IN4_Pin GPIO_PIN_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  设置L298N驱动的电机方向</span></span><br><span class="line"><span class="comment">  * @param  motor: 选择电机 (MOTOR_LEFT 或 MOTOR_RIGHT)</span></span><br><span class="line"><span class="comment">  * @param  direction: 选择方向 (DIR_FORWARD, DIR_BACKWARD, 或 DIR_STOP)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_motor_direction_l298n</span><span class="params">(Motor_TypeDef motor, Direction_TypeDef direction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (motor == MOTOR_LEFT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == DIR_FORWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(L_IN1_GPIO_Port, L_IN1_Pin, GPIO_PIN_SET);   <span class="comment">// IN1 = High</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN2_GPIO_Port, L_IN2_Pin, GPIO_PIN_RESET); <span class="comment">// IN2 = Low</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == DIR_BACKWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(L_IN1_GPIO_Port, L_IN1_Pin, GPIO_PIN_RESET); <span class="comment">// IN1 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN2_GPIO_Port, L_IN2_Pin, GPIO_PIN_SET);   <span class="comment">// IN2 = High</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// DIR_STOP (快速制动)</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN1_GPIO_Port, L_IN1_Pin, GPIO_PIN_RESET); <span class="comment">// IN1 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(L_IN2_GPIO_Port, L_IN2_Pin, GPIO_PIN_RESET); <span class="comment">// IN2 = Low</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motor == MOTOR_RIGHT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == DIR_FORWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(R_IN3_GPIO_Port, R_IN3_Pin, GPIO_PIN_SET);   <span class="comment">// IN3 = High</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN4_GPIO_Port, R_IN4_Pin, GPIO_PIN_RESET); <span class="comment">// IN4 = Low</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == DIR_BACKWARD) &#123;</span><br><span class="line">            HAL_GPIO_WritePin(R_IN3_GPIO_Port, R_IN3_Pin, GPIO_PIN_RESET); <span class="comment">// IN3 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN4_GPIO_Port, R_IN4_Pin, GPIO_PIN_SET);   <span class="comment">// IN4 = High</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// DIR_STOP (快速制动)</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN3_GPIO_Port, R_IN3_Pin, GPIO_PIN_RESET); <span class="comment">// IN3 = Low</span></span><br><span class="line">            HAL_GPIO_WritePin(R_IN4_GPIO_Port, R_IN4_Pin, GPIO_PIN_RESET); <span class="comment">// IN4 = Low</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数使用<code>HAL_GPIO_WritePin()</code>函数 23 来设置L298N的INx引脚电平，遵循L298N的真值表 14。注意，L298N的“停止”可以通过将两个INx引脚都设为低电平（快速制动）或将使能引脚（ENA&#x2F;ENB）设为低电平（自由滑行停止）来实现。上述函数实现了快速制动。</p>
<h3 id="4-5-高层机器人运动函数"><a href="#4-5-高层机器人运动函数" class="headerlink" title="4.5. 高层机器人运动函数"></a>4.5. 高层机器人运动函数</h3><p>基于底层的速度和方向控制函数，可以封装出更高级别的机器人整体运动函数。这种分层设计提高了代码的模块化程度和可重用性。如果将来更换电机驱动器（例如，从L298N换到DRV8833），主要修改可能仅限于底层的方向控制函数，而高层API（如<code>car_forward()</code>）可以保持不变，这大大增强了代码的可维护性和适应性。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设htim_L和htim_R是分别用于左右电机的定时器句柄</span></span><br><span class="line"><span class="comment">// 假设TIM_CHANNEL_L和TIM_CHANNEL_R是对应的PWM通道</span></span><br><span class="line"><span class="keyword">extern</span> TIM_HandleTypeDef htim_L; <span class="comment">// 例如 htim3</span></span><br><span class="line"><span class="keyword">extern</span> TIM_HandleTypeDef htim_R; <span class="comment">// 例如 htim3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM_CHANNEL_L TIM_CHANNEL_3 <span class="comment">// 示例</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM_CHANNEL_R TIM_CHANNEL_4 <span class="comment">// 示例</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车前进</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_forward</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_FORWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_FORWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车后退</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_backward</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_BACKWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_BACKWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车左转 (原地旋转)</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_turn_left_pivot</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_BACKWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_FORWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车右转 (原地旋转)</span></span><br><span class="line"><span class="comment">  * @param  speed_percentage: 速度百分比 (0-100)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_turn_right_pivot</span><span class="params">(<span class="type">uint8_t</span> speed_percentage)</span> &#123;</span><br><span class="line">    set_motor_direction_l298n(MOTOR_LEFT, DIR_FORWARD);</span><br><span class="line">    set_motor_direction_l298n(MOTOR_RIGHT, DIR_BACKWARD);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, speed_percentage);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, speed_percentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  小车停止 (通过PWM占空比为0实现，方向控制引脚保持上次状态或设为制动)</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">car_stop_pwm</span><span class="params">()</span> &#123;</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_L, TIM_CHANNEL_L, <span class="number">0</span>);</span><br><span class="line">    set_motor_pwm_speed(&amp;htim_R, TIM_CHANNEL_R, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 可选: 执行快速制动</span></span><br><span class="line">    <span class="comment">// set_motor_direction_l298n(MOTOR_LEFT, DIR_STOP);</span></span><br><span class="line">    <span class="comment">// set_motor_direction_l298n(MOTOR_RIGHT, DIR_STOP);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些高层函数调用了前面定义的底层函数来实现小车的各种运动状态 7。转向策略可以有多种，例如原地旋转（一个轮子前进，另一个轮子后退）或曲线转向（一个轮子比另一个轮子转得快）5。</p>
<h3 id="4-6-主循环测试"><a href="#4-6-主循环测试" class="headerlink" title="4.6. 主循环测试"></a>4.6. 主循环测试</h3><p>在<code>main()</code>函数的<code>while(1)</code>循环中，可以编写简单的测试代码来验证这些运动函数的正确性，例如：</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//... HAL_Init(), SystemClock_Config(), MX_GPIO_Init(), MX_TIM3_Init()...</span></span><br><span class="line">    <span class="comment">// 假设htim_L 和 htim_R 已正确初始化并赋值为 &amp;htim3</span></span><br><span class="line">    <span class="comment">// 假设TIM_CHANNEL_L 和 TIM_CHANNEL_R 已正确定义</span></span><br><span class="line"></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim_L, TIM_CHANNEL_L);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim_R, TIM_CHANNEL_R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        car_forward(<span class="number">50</span>);    <span class="comment">// 前进，速度50%</span></span><br><span class="line">        HAL_Delay(<span class="number">2000</span>);    <span class="comment">// 持续2秒</span></span><br><span class="line">        car_stop_pwm();     <span class="comment">// 停止</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);    <span class="comment">// 停止1秒</span></span><br><span class="line"></span><br><span class="line">        car_turn_left_pivot(<span class="number">30</span>); <span class="comment">// 左转，速度30%</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);    <span class="comment">// 持续1秒</span></span><br><span class="line">        car_stop_pwm();     <span class="comment">// 停止</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);    <span class="comment">// 停止1秒</span></span><br><span class="line">        </span><br><span class="line">        car_backward(<span class="number">50</span>);   <span class="comment">// 后退，速度50%</span></span><br><span class="line">        HAL_Delay(<span class="number">2000</span>);</span><br><span class="line">        car_stop_pwm();</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        car_turn_right_pivot(<span class="number">30</span>); <span class="comment">// 右转，速度30%</span></span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">        car_stop_pwm();</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第5节：PID控制增强性能简介"><a href="#第5节：PID控制增强性能简介" class="headerlink" title="第5节：PID控制增强性能简介"></a>第5节：PID控制增强性能简介</h2><h3 id="5-1-为何需要PID？开环控制的局限性"><a href="#5-1-为何需要PID？开环控制的局限性" class="headerlink" title="5.1. 为何需要PID？开环控制的局限性"></a>5.1. 为何需要PID？开环控制的局限性</h3><p>第4节中实现的基本运动控制属于“开环控制”。这意味着MCU向电机发出指令（例如，设置一定的PWM占空比），但并不关心电机是否真正达到了期望的速度，或者小车是否真的在直线行驶。</p>
<p>开环控制的性能会受到多种因素的影响，例如：</p>
<ul>
<li>电池电压波动：电池电量下降时，相同的PWM占空比可能无法产生相同的电机转速。</li>
<li>地面摩擦力变化：在不同表面行驶时，电机负载会变化。</li>
<li>电机个体差异：即使是同型号的电机，其特性也可能略有不同。</li>
<li>负载变化：小车上装载物品的重量变化。</li>
</ul>
<p>为了克服这些局限性，引入了“闭环控制”策略，其中PID（比例-积分-微分）控制器是最常用的一种。PID控制器通过使用传感器反馈来持续监测系统状态，并根据期望状态与实际状态之间的误差来调整控制输出，从而提高系统的性能和鲁棒性 21。</p>
<h3 id="5-2-PID基本理论解释"><a href="#5-2-PID基本理论解释" class="headerlink" title="5.2. PID基本理论解释"></a>5.2. PID基本理论解释</h3><p>PID控制器的核心思想是根据当前误差、累积误差和误差变化率来计算控制量。</p>
<ul>
<li><strong>误差 (Error, e(t)):</strong> 期望设定点（例如，目标速度）与实际测量过程变量（例如，编码器测得的当前速度）之间的差值 21。</li>
<li><strong>比例 (Proportional, P) 项 (Kp​⋅e(t)):</strong><ul>
<li>控制器输出与当前误差成正比。误差越大，P项产生的校正作用也越大。</li>
<li><strong>作用：</strong> 加快系统响应速度，减小稳态误差，但通常无法完全消除稳态误差。过大的Kp​会导致系统振荡甚至不稳定 21。</li>
</ul>
</li>
<li><strong>积分 (Integral, I) 项 (Ki​⋅∫e(t)dt):</strong><ul>
<li>累积过去的误差。只要存在误差，I项就会持续作用，直到误差被消除。</li>
<li><strong>作用：</strong> 消除系统的稳态误差。过大的Ki​会导致积分饱和（积分 विंडअप），引起系统超调和振荡，响应变慢 21。</li>
</ul>
</li>
<li><strong>微分 (Derivative, D) 项 (Kd​⋅dtde(t)​):</strong><ul>
<li>根据误差的变化率来预测未来的误差趋势，并提前进行校正。</li>
<li><strong>作用：</strong> 减小超调，抑制振荡，改善系统稳定性，加快稳定过程。D项对过程变量中的噪声非常敏感，过大的Kd​或噪声较大的系统可能导致输出剧烈波动 21。</li>
</ul>
</li>
</ul>
<p>PID控制律公式：</p>
<p>控制器的输出 Output(t) 由这三项加权求和得到：</p>
<p>Output(t)&#x3D;Kp​e(t)+Ki​∫0t​e(τ)dτ+Kd​dtde(t)​</p>
<p>其中，Kp​, Ki​, Kd​ 分别是比例、积分和微分增益系数，需要根据具体系统进行整定 21。</p>
<p>理解P、I、D各项的独立作用及其组合效应是PID参数整定的基础。每个参数都针对系统响应的不同方面进行调整。PID控制器本质上是试图基于当前和过去的状态来预测未来并进行修正，从而使系统能够自适应地达到期望状态。</p>
<h3 id="5-3-反馈的必要性：引入编码器"><a href="#5-3-反馈的必要性：引入编码器" class="headerlink" title="5.3. 反馈的必要性：引入编码器"></a>5.3. 反馈的必要性：引入编码器</h3><p>为了使PID控制器能够工作，必须能够测量“过程变量”（例如电机速度）。旋转编码器是电机控制中常用的传感器，用于提供这种反馈 20。编码器产生的脉冲信号可以被转换成电机的速度或位置信息。下一节将详细介绍如何在STM32F103C8T6上集成和读取编码器数据。</p>
<h2 id="第6节：STM32F103C8T6集成编码器"><a href="#第6节：STM32F103C8T6集成编码器" class="headerlink" title="第6节：STM32F103C8T6集成编码器"></a>第6节：STM32F103C8T6集成编码器</h2><h3 id="6-1-理解正交编码器"><a href="#6-1-理解正交编码器" class="headerlink" title="6.1. 理解正交编码器"></a>6.1. 理解正交编码器</h3><p>正交编码器（或称A&#x2F;B相编码器）通常有两个输出通道，分别称为A相和B相。这两个通道输出方波脉冲信号，并且A相和B相信号之间存在90度的相位差。通过检测这两个信号的脉冲数量和相位关系，可以确定电机旋转的距离（或角度）和方向 20。编码器的一个关键参数是每转脉冲数（Pulses Per Revolution, PPR），它表示电机轴旋转一周时，A相或B相输出的脉冲个数 33。</p>
<h3 id="6-2-配置STM32定时器的编码器模式"><a href="#6-2-配置STM32定时器的编码器模式" class="headerlink" title="6.2. 配置STM32定时器的编码器模式"></a>6.2. 配置STM32定时器的编码器模式</h3><p>STM32微控制器的通用定时器（例如STM32F103上的TIM1, TIM2, TIM3, TIM4，具体型号需查阅数据手册确认是否支持编码器接口）可以配置为“编码器接口模式”，从而硬件解码编码器信号 20。</p>
<p><strong>STM32CubeMX 设置步骤 20:</strong></p>
<ol>
<li><strong>选择合适的定时器：</strong> 例如，选择TIM3。</li>
<li><strong>使能编码器模式：</strong> 在定时器的“Combined Channels”配置中，选择“Encoder Mode”。</li>
<li><strong>配置编码器接口参数：</strong><ul>
<li><strong>Encoder Mode：</strong> 选择“Encoder Mode TI1 and TI2”。这将使用定时器的两个输入通道（TI1FP1和TI2FP2）分别连接编码器的A相和B相信号。</li>
<li><strong>Counter Period (ARR)：</strong> 对于16位定时器，通常将ARR设置为最大值65535（0xFFFF），以允许在计数器溢出前回转较大范围。也可以根据期望的计数行为进行配置。</li>
<li><strong>Input Filter (ICx Filter)：</strong> 可以为输入通道配置数字滤波器，以减少外部噪声对编码器信号的干扰。</li>
</ul>
</li>
<li><strong>GPIO引脚配置：</strong> 连接到编码器A相和B相的GPIO引脚（例如，TIM3_CH1和TIM3_CH2对应的引脚）将自动配置为定时器输入复用功能。</li>
<li><strong>启动定时器：</strong> 在代码中，使用 <code>HAL_TIM_Encoder_Start(&amp;htim_encoder, TIM_CHANNEL_ALL);</code> 启动定时器的编码器模式 20。</li>
</ol>
<p>一旦配置完成并启动，定时器的计数器寄存器（TIMx-&gt;CNT）会根据编码器的旋转自动增加或减少。</p>
<p>使用硬件编码器模式比通过外部中断手动处理编码器脉冲要高效得多，尤其是在电机转速较高时。它将计数和方向检测的任务卸载到硬件，从而释放CPU资源 [39 (Scott Seidman的评论), 20]。</p>
<h3 id="6-3-读取编码器计数并计算速度"><a href="#6-3-读取编码器计数并计算速度" class="headerlink" title="6.3. 读取编码器计数并计算速度"></a>6.3. 读取编码器计数并计算速度</h3><h4 id="6-3-1-读取原始计数值"><a href="#6-3-1-读取原始计数值" class="headerlink" title="6.3.1. 读取原始计数值"></a>6.3.1. 读取原始计数值</h4><p>启动编码器模式后，可以通过读取定时器的计数器寄存器来获取原始计数值：</p>
<p>current_counts &#x3D; __HAL_TIM_GET_COUNTER(&amp;htim_encoder); 20。</p>
<h4 id="6-3-2-计算速度-例如，每采样时间的脉冲数或RPM"><a href="#6-3-2-计算速度-例如，每采样时间的脉冲数或RPM" class="headerlink" title="6.3.2. 计算速度 (例如，每采样时间的脉冲数或RPM)"></a>6.3.2. 计算速度 (例如，每采样时间的脉冲数或RPM)</h4><p>速度的计算需要周期性地采样编码器的计数值。可以使用另一个定时器产生周期性中断（例如，每10ms或100ms）来进行速度计算。</p>
<ol>
<li><p>在一个固定的采样时间间隔 Δt 内，读取编码器计数值的变化量 Δcounts：</p>
<p> Δcounts&#x3D;current_counts−previous_counts</p>
<p> 需要处理计数器溢出&#x2F;下溢的情况，特别是当ARR值不是足够大或者位置信息发生回绕时 20。对于16位计数器和ARR&#x3D;65535，当从0xFFFF变为0x0000（正转）或从0x0000变为0xFFFF（反转）时，需要特殊处理差值。</p>
</li>
<li><p>将脉冲数转换为转速（例如，RPM - 每分钟转数）：</p>
<p> SpeedRPS​&#x3D;(Δcounts&#x2F;PPRencoder​)&#x2F;Δtseconds​ (转&#x2F;秒)</p>
<p> SpeedRPM​&#x3D;SpeedRPS​×60 (转&#x2F;分钟)</p>
<p> 其中，PPRencoder​ 是编码器每转产生的脉冲数，Δtseconds​ 是采样时间间隔（以秒为单位）。</p>
<p> 例如，34 提供了一个RPM计算公式：rpm&#x3D;(timer_counter&#x2F;encoder_counts_per_rev)×60.0。这里的 timer_counter 对应于 Δcounts，encoder_counts_per_rev 对应于 PPRencoder​，并且假设这个计算是在1秒的时间间隔内完成的。</p>
<p> 36 中描述的M方法公式为 n&#x3D;M0​&#x2F;(C⋅T0​)，其中 M0​ 是 Δcounts，C 是 PPRencoder​，T0​ 是采样时间 Δtseconds​。</p>
</li>
</ol>
<h4 id="6-3-3-C代码结构示例-编码器读取与速度计算"><a href="#6-3-3-C代码结构示例-编码器读取与速度计算" class="headerlink" title="6.3.3. C代码结构示例 (编码器读取与速度计算)"></a>6.3.3. C代码结构示例 (编码器读取与速度计算)</h4><p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码器数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TIM_HandleTypeDef* htim;         <span class="comment">// 编码器定时器句柄</span></span><br><span class="line">    <span class="type">int16_t</span>            previous_counter_value; <span class="comment">// 上一次的计数值 (假设为16位定时器)</span></span><br><span class="line">    <span class="type">int32_t</span>            current_position;       <span class="comment">// 累积的位置 (可选)</span></span><br><span class="line">    <span class="type">float</span>              current_speed_rps;    <span class="comment">// 当前速度 (转/秒)</span></span><br><span class="line">    <span class="type">uint16_t</span>           ppr;                  <span class="comment">// 编码器每转脉冲数</span></span><br><span class="line">    <span class="type">uint32_t</span>           last_update_tick;     <span class="comment">// 上次更新速度的时间戳 (ms)</span></span><br><span class="line">    <span class="type">float</span>              sample_time_seconds;  <span class="comment">// 速度计算的采样周期 (秒)</span></span><br><span class="line">&#125; Encoder_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：在定时器中断服务程序中更新速度</span></span><br><span class="line"><span class="comment">// 假设此函数由一个周期性定时器中断调用，例如每10ms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_UpdateSpeed</span><span class="params">(Encoder_TypeDef* encoder)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> current_tick = HAL_GetTick();</span><br><span class="line">    <span class="type">int16_t</span> current_counter = (<span class="type">int16_t</span>)__HAL_TIM_GET_COUNTER(encoder-&gt;htim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算计数值差值，考虑16位计数器溢出</span></span><br><span class="line">    <span class="type">int16_t</span> diff = current_counter - encoder-&gt;previous_counter_value;</span><br><span class="line">    <span class="comment">// 简单的溢出处理：如果差值绝对值大于半个计数范围，则认为发生了溢出</span></span><br><span class="line">    <span class="comment">// (0xFFFF / 2 = 32767)</span></span><br><span class="line">    <span class="comment">// if (diff &gt; 30000) &#123; // 假设反向溢出 (e.g., 0 -&gt; 65530)</span></span><br><span class="line">    <span class="comment">//     diff -= 65536;</span></span><br><span class="line">    <span class="comment">// &#125; else if (diff &lt; -30000) &#123; // 假设正向溢出 (e.g., 65530 -&gt; 0)</span></span><br><span class="line">    <span class="comment">//     diff += 65536;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 更稳健的溢出处理可能需要更复杂的逻辑或依赖于定时器更新事件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> time_elapsed_seconds = (<span class="type">float</span>)(current_tick - encoder-&gt;last_update_tick) / <span class="number">1000.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (time_elapsed_seconds &gt;= encoder-&gt;sample_time_seconds) &#123; <span class="comment">// 确保达到采样周期</span></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;ppr &gt; <span class="number">0</span> &amp;&amp; time_elapsed_seconds &gt; <span class="number">0.0001f</span>) &#123; <span class="comment">// 防止除以零</span></span><br><span class="line">            encoder-&gt;current_speed_rps = ((<span class="type">float</span>)diff / (<span class="type">float</span>)encoder-&gt;ppr) / time_elapsed_seconds;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encoder-&gt;current_speed_rps = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encoder-&gt;previous_counter_value = current_counter;</span><br><span class="line">        encoder-&gt;last_update_tick = current_tick;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可选：累积位置</span></span><br><span class="line">        <span class="comment">// encoder-&gt;current_position += diff;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>速度计算的准确性和频率直接影响PID控制的性能。一个充满噪声的速度信号（例如，来自低PPR编码器或更新频率不足）会使PID参数整定变得困难，并可能导致系统不稳定，尤其是当微分项（Kd）增益较高时。因此，选择合适的编码器和设计恰当的速度计算周期非常重要。</p>
<h2 id="第7节：实现电机PID速度控制-C代码与HAL库"><a href="#第7节：实现电机PID速度控制-C代码与HAL库" class="headerlink" title="第7节：实现电机PID速度控制 (C代码与HAL库)"></a>第7节：实现电机PID速度控制 (C代码与HAL库)</h2><h3 id="7-1-PID数据结构定义"><a href="#7-1-PID数据结构定义" class="headerlink" title="7.1. PID数据结构定义"></a>7.1. PID数据结构定义</h3><p>为每个需要PID控制的电机定义一个C结构体，用于存储PID参数和相关的状态变量 21。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> Kp;                   <span class="comment">// 比例增益</span></span><br><span class="line">    <span class="type">float</span> Ki;                   <span class="comment">// 积分增益</span></span><br><span class="line">    <span class="type">float</span> Kd;                   <span class="comment">// 微分增益</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> setpoint;             <span class="comment">// 目标设定值 (例如，期望速度 RPS)</span></span><br><span class="line">    <span class="type">float</span> last_error;           <span class="comment">// 上一次的误差</span></span><br><span class="line">    <span class="type">float</span> integral_sum;         <span class="comment">// 积分累计值</span></span><br><span class="line">    <span class="type">float</span> integral_max;         <span class="comment">// 积分累计值的上限 (用于抗积分饱和)</span></span><br><span class="line">    <span class="type">float</span> integral_min;         <span class="comment">// 积分累计值的下限</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> output_min;           <span class="comment">// PID输出值的下限 (例如，PWM占空比的最小值0)</span></span><br><span class="line">    <span class="type">float</span> output_max;           <span class="comment">// PID输出值的上限 (例如，PWM占空比的最大值100)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于基于时间的PID计算</span></span><br><span class="line">    <span class="comment">// uint32_t last_compute_time;  // 上次计算PID的时间戳</span></span><br><span class="line">    <span class="comment">// float sample_time_seconds;   // PID计算周期 (秒)</span></span><br><span class="line">&#125; PID_Controller_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为左右电机分别实例化PID控制器</span></span><br><span class="line">PID_Controller_TypeDef pid_left_motor;</span><br><span class="line">PID_Controller_TypeDef pid_right_motor;</span><br></pre></td></tr></table></figure>

<p>这种结构化方法有助于管理多个PID控制器的参数和状态，例如在双电机驱动的机器人小车中，左右轮通常需要独立的PID控制器 21。</p>
<h3 id="7-2-PID初始化函数-pid-init"><a href="#7-2-PID初始化函数-pid-init" class="headerlink" title="7.2. PID初始化函数 pid_init()"></a>7.2. PID初始化函数 <code>pid_init()</code></h3><p>创建一个函数来初始化PID控制器的参数，包括增益系数、设定点（可以后续修改）、输出限制、积分限制和采样时间。同时，重置误差和积分累积值。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  初始化PID控制器参数</span></span><br><span class="line"><span class="comment">  * @param  pid: 指向PID控制器结构体的指针</span></span><br><span class="line"><span class="comment">  * @param  Kp: 比例增益</span></span><br><span class="line"><span class="comment">  * @param  Ki: 积分增益</span></span><br><span class="line"><span class="comment">  * @param  Kd: 微分增益</span></span><br><span class="line"><span class="comment">  * @param  setpoint: 初始目标设定值</span></span><br><span class="line"><span class="comment">  * @param  out_min: PID输出下限</span></span><br><span class="line"><span class="comment">  * @param  out_max: PID输出上限</span></span><br><span class="line"><span class="comment">  * @param  integral_limit: 积分累积值的绝对值上限</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pid_init</span><span class="params">(PID_Controller_TypeDef* pid, <span class="type">float</span> Kp, <span class="type">float</span> Ki, <span class="type">float</span> Kd, </span></span><br><span class="line"><span class="params">              <span class="type">float</span> setpoint, <span class="type">float</span> out_min, <span class="type">float</span> out_max, <span class="type">float</span> integral_limit)</span> &#123;</span><br><span class="line">    pid-&gt;Kp = Kp;</span><br><span class="line">    pid-&gt;Ki = Ki;</span><br><span class="line">    pid-&gt;Kd = Kd;</span><br><span class="line">    pid-&gt;setpoint = setpoint;</span><br><span class="line">    pid-&gt;output_min = out_min;</span><br><span class="line">    pid-&gt;output_max = out_max;</span><br><span class="line">    pid-&gt;integral_max = integral_limit;</span><br><span class="line">    pid-&gt;integral_min = -integral_limit; <span class="comment">// 对称的积分限制</span></span><br><span class="line"></span><br><span class="line">    pid-&gt;last_error = <span class="number">0.0f</span>;</span><br><span class="line">    pid-&gt;integral_sum = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// pid-&gt;last_compute_time = HAL_GetTick(); // 如果使用基于时间戳的dt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此初始化函数参考了21中的<code>set_pid</code>和37中的<code>PID</code>构造函数的设计思想。</p>
<h3 id="7-3-PID计算函数-pid-compute"><a href="#7-3-PID计算函数-pid-compute" class="headerlink" title="7.3. PID计算函数 pid_compute()"></a>7.3. PID计算函数 <code>pid_compute()</code></h3><p>此函数将周期性地被调用（例如，每隔一个固定的<code>sample_time_seconds</code>），根据当前测量值计算PID输出。</p>
<p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  执行PID计算</span></span><br><span class="line"><span class="comment">  * @param  pid: 指向PID控制器结构体的指针</span></span><br><span class="line"><span class="comment">  * @param  current_value: 当前测量值 (例如，当前电机速度 RPS)</span></span><br><span class="line"><span class="comment">  * @param  dt: 离散时间间隔 (两次计算之间的时间差，单位：秒)</span></span><br><span class="line"><span class="comment">  * @retval float: PID计算得到的输出值 (例如，PWM占空比百分比)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">pid_compute</span><span class="params">(PID_Controller_TypeDef* pid, <span class="type">float</span> current_value, <span class="type">float</span> dt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dt &lt;= <span class="number">0.0f</span>) &#123; <span class="comment">// 防止dt为零或负数导致计算错误</span></span><br><span class="line">        <span class="keyword">return</span> pid-&gt;output_min; <span class="comment">// 或返回上一次的有效输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 计算误差</span></span><br><span class="line">    <span class="type">float</span> error = pid-&gt;setpoint - current_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 比例项</span></span><br><span class="line">    <span class="type">float</span> P_term = pid-&gt;Kp * error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 积分项 (带抗积分饱和)</span></span><br><span class="line">    pid-&gt;integral_sum += pid-&gt;Ki * error * dt;</span><br><span class="line">    <span class="keyword">if</span> (pid-&gt;integral_sum &gt; pid-&gt;integral_max) &#123;</span><br><span class="line">        pid-&gt;integral_sum = pid-&gt;integral_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid-&gt;integral_sum &lt; pid-&gt;integral_min) &#123;</span><br><span class="line">        pid-&gt;integral_sum = pid-&gt;integral_min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> I_term = pid-&gt;integral_sum; <span class="comment">// 在某些实现中，I_term = Ki * integral_sum</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 微分项</span></span><br><span class="line">    <span class="type">float</span> derivative = (error - pid-&gt;last_error) / dt;</span><br><span class="line">    <span class="type">float</span> D_term = pid-&gt;Kd * derivative;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新上一次误差，用于下次微分计算</span></span><br><span class="line">    pid-&gt;last_error = error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 计算总输出</span></span><br><span class="line">    <span class="type">float</span> output = P_term + I_term + D_term;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 输出限幅</span></span><br><span class="line">    <span class="keyword">if</span> (output &gt; pid-&gt;output_max) &#123;</span><br><span class="line">        output = pid-&gt;output_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (output &lt; pid-&gt;output_min) &#123;</span><br><span class="line">        output = pid-&gt;output_min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此计算函数参考了21的<code>apply_pid</code>和37的<code>PID_Compute</code>以及21中的PID实现逻辑。在积分项和微分项的计算中，<code>dt</code>（时间间隔）应该是两次PID计算之间的_实际_经过时间，而不是简单地使用配置的采样时间。这可以通过<code>HAL_GetTick()</code>来测量，以获得更准确的控制，尤其是在控制循环的定时不是绝对精确的情况下。</p>
<h3 id="7-4-将PID输出应用于PWM占空比"><a href="#7-4-将PID输出应用于PWM占空比" class="headerlink" title="7.4. 将PID输出应用于PWM占空比"></a>7.4. 将PID输出应用于PWM占空比</h3><p><code>pid_compute()</code>函数返回的<code>output</code>值（例如，范围在0到100之间，如果<code>output_min/max</code>如此设置）需要被映射到控制电机PWM的占空比范围（例如，对于定时器的ARR值为999，则PWM原始值范围为0-999）。</p>
<p>如果PID的输出设计为可以为负值（例如，当PID同时控制方向和速度时），则输出的符号可以决定电机方向，其绝对值决定PWM大小。但在本报告中，我们假设方向由高层函数（如<code>car_forward</code>）独立控制，PID仅输出一个正值（0-100）来控制速度大小。</p>
<p>可以使用第4节中定义的set_motor_pwm_speed()函数来应用PID计算得到的PWM占空比：</p>
<p>set_motor_pwm_speed(&amp;htim_motor, TIM_CHANNEL_MOTOR, (uint8_t)pid_output);</p>
<p>其中pid_output是pid_compute返回的经过限幅的控制量。</p>
<h3 id="7-5-带PID的主控制循环"><a href="#7-5-带PID的主控制循环" class="headerlink" title="7.5. 带PID的主控制循环"></a>7.5. 带PID的主控制循环</h3><ol>
<li>初始化左右电机的PID控制器（调用<code>pid_init()</code>）。</li>
<li>初始化编码器，并启动周期性的速度计算（例如，通过定时器中断）。</li>
<li>在一个周期性循环中（例如，由一个专用定时器中断触发，中断周期为PID的<code>sample_time_seconds</code>）： a. 从编码器获取左右电机的当前速度（<code>current_speed_L</code>, <code>current_speed_R</code>）。 b. 计算自上次PID计算以来经过的实际时间<code>dt</code>。 c. 根据用户输入或更高级别的导航逻辑，设置左右电机的期望速度（<code>pid_left_motor.setpoint</code>, <code>pid_right_motor.setpoint</code>）。 d. 为左电机计算PID输出：<code>pwm_L = pid_compute(&amp;pid_left_motor, current_speed_L, dt);</code> e. 为右电机计算PID输出：<code>pwm_R = pid_compute(&amp;pid_right_motor, current_speed_R, dt);</code> f. 根据期望的运动方向（例如，如果设定点为负，则方向为反向，但这需要PID输出和方向逻辑的配合），设置电机方向。为简化起见，这里假设PID输出始终为正（0-100），方向由<code>car_forward()</code>等函数预先设定。 g. 将计算得到的<code>pwm_L</code>（经过适当转换）应用到左电机的PWM控制引脚（ENA）。 h. 将计算得到的<code>pwm_R</code>（经过适当转换）应用到右电机的PWM控制引脚（ENB）。</li>
</ol>
<p>PID控制回路、编码器读数和PWM更新必须仔细定时和同步。使用硬件定时器中断来执行主PID控制循环，可以确保一致的执行时序，这对于PID控制的稳定性至关重要。这种系统集成确保了控制器能够基于最新的反馈信息做出及时响应。</p>
<h2 id="第8节：PID控制器参数整定"><a href="#第8节：PID控制器参数整定" class="headerlink" title="第8节：PID控制器参数整定"></a>第8节：PID控制器参数整定</h2><h3 id="8-1-整定的目标"><a href="#8-1-整定的目标" class="headerlink" title="8.1. 整定的目标"></a>8.1. 整定的目标</h3><p>PID参数整定的目标是找到一组Kp​,Ki​,Kd​值，使得控制系统对于特定的机器人小车能够表现出稳定且良好的动态性能：快速的响应时间、最小的超调量、较短的稳定时间以及零稳态误差（或在可接受范围内）32。</p>
<h3 id="8-2-手动整定方法-试凑法"><a href="#8-2-手动整定方法-试凑法" class="headerlink" title="8.2. 手动整定方法 (试凑法)"></a>8.2. 手动整定方法 (试凑法)</h3><p>这是一种常用的、基于经验的整定方法 30：</p>
<ol>
<li><strong>从P控制器开始：</strong> 将Ki​和Kd​设为0。</li>
<li><strong>调整Kp​：</strong> 从一个较小的值开始，逐渐增加Kp​。观察系统响应（例如，电机速度达到设定值的过程）。目标是获得一个相对较快且没有持续振荡的响应。如果系统开始出现持续振荡或变得不稳定，则减小Kp​。通常将Kp​设置在系统开始轻微振荡的临界值的50%-70%左右。</li>
<li><strong>加入I控制器：</strong> 在选定的Kp​值基础上，从一个较小的值开始逐渐增加Ki​。Ki​的作用是消除稳态误差。观察系统是否能够最终达到设定点。如果Ki​过大，可能会导致超调增加、响应变慢或产生振荡（积分饱和）。如果需要，可以回头微调Kp​。</li>
<li><strong>加入D控制器 (如果需要)：</strong> 如果系统在P和I控制下仍存在较大的超调或振荡，可以尝试加入一个较小的Kd​值来抑制这些现象，提高系统的阻尼。Kd​对系统噪声敏感，因此不宜设置过大。在许多速度控制应用中，PD或PI控制器可能就足够了，不一定需要完整的PID。</li>
<li><strong>迭代优化：</strong> PID参数整定通常是一个迭代的过程。对一个参数的调整可能会影响其他参数的最佳值。需要耐心观察和反复试验。</li>
</ol>
<h3 id="8-3-Kp​-Ki​-Kd​对系统响应的影响"><a href="#8-3-Kp​-Ki​-Kd​对系统响应的影响" class="headerlink" title="8.3. Kp​,Ki​,Kd​对系统响应的影响"></a>8.3. Kp​,Ki​,Kd​对系统响应的影响</h3><p>下表总结了各PID参数对系统响应特性的主要影响 21：</p>
<p><strong>表3：PID参数整定指南</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>参数</strong></td>
<td><strong>增大该参数的影响</strong></td>
<td><strong>减小该参数的影响</strong></td>
<td><strong>参数过大的常见问题</strong></td>
</tr>
<tr>
<td>Kp​</td>
<td>加快响应速度，减小稳态误差，增加系统振荡性</td>
<td>减慢响应速度，增大稳态误差，减小系统振荡性</td>
<td>剧烈超调，持续振荡，系统不稳定</td>
</tr>
<tr>
<td>Ki​</td>
<td>消除稳态误差，可能增加超调和稳定时间</td>
<td>稳态误差较大，响应可能更快（如果Ki​之前过大）</td>
<td>积分饱和，超调过大，响应缓慢，系统振荡</td>
</tr>
<tr>
<td>Kd​</td>
<td>减小超调，缩短稳定时间，提高系统稳定性，对噪声敏感</td>
<td>增加超调，延长稳定时间，可能降低稳定性</td>
<td>放大高频噪声，导致输出抖动，系统不稳定</td>
</tr>
</tbody></table>
<p>此表为用户在整定过程中提供了一个快速参考，帮助理解参数调整的后果并解决常见的整定问题。</p>
<h3 id="8-4-机器人小车PID整定实用技巧"><a href="#8-4-机器人小车PID整定实用技巧" class="headerlink" title="8.4. 机器人小车PID整定实用技巧"></a>8.4. 机器人小车PID整定实用技巧</h3><ul>
<li><strong>独立测试：</strong> 首先在机器人轮子离地或机器人被架空的情况下，对单个电机的速度控制环进行整定。</li>
<li><strong>参数迁移：</strong> 一个电机整定完成后，可以将得到的参数作为另一个电机PID控制器的初始参数。由于电机和机械结构可能存在差异，通常还需要对第二个电机进行微调。</li>
<li><strong>实地测试：</strong> 在机器人实际运行的地面上进行最终测试和调整，因为地面摩擦力会影响系统响应。</li>
<li><strong>数据记录与可视化：</strong> 通过串口将设定点、当前速度、PID输出等数据发送到PC端，并使用串口助手或绘图工具（如STM32CubeIDE的SWV功能 20，或自定义的绘图软件）进行可视化。这有助于直观地分析系统响应曲线，从而更有效地进行参数调整。</li>
<li><strong>差速驱动的协调：</strong> 对于差速驱动机器人，要实现直线行驶，两轮的PID控制器都需要良好整定，并且两轮的设定速度必须相等。由于机械差异，可能需要为左右轮设置略微不同的PID增益。更高级的控制策略可能包括一个上层控制器，用于校正航向偏差（例如，使用IMU反馈）或确保两轮行驶距离一致（例如，通过PID控制两轮编码器计数的差值 38）。</li>
<li><strong>注意安全：</strong> 在整定过程中，电机可能会突然高速旋转或反向，确保机器人处于安全的环境中，避免损坏或伤人。</li>
</ul>
<h3 id="8-5-Ziegler-Nichols整定法-简述"><a href="#8-5-Ziegler-Nichols整定法-简述" class="headerlink" title="8.5. Ziegler-Nichols整定法 (简述)"></a>8.5. Ziegler-Nichols整定法 (简述)</h3><p>Ziegler-Nichols方法是一种启发式的PID参数整定方法，适用于手动整定较为困难的系统 30。它通常包括两个步骤：首先，在纯比例控制（Ki​&#x3D;0,Kd​&#x3D;0）下，找到使系统产生持续等幅振荡的临界比例增益Ku​和此时的振荡周期Tu​。然后根据Ku​和Tu​的值，通过经验公式计算出Kp​,Ki​,Kd​的初始值。</p>
<h2 id="第9节：总结与展望"><a href="#第9节：总结与展望" class="headerlink" title="第9节：总结与展望"></a>第9节：总结与展望</h2><h3 id="9-1-成果总结"><a href="#9-1-成果总结" class="headerlink" title="9.1. 成果总结"></a>9.1. 成果总结</h3><p>本报告详细阐述了如何使用STM32F103C8T6微控制器设计和实现一个双轮差速驱动机器人小车的电机控制系统。内容涵盖了STM32CubeIDE的配置、L298N电机驱动器的接口与控制、通过PWM实现电机调速、集成旋转编码器以获取速度反馈，以及PID控制理论的讲解和C语言实现。通过本报告的学习，用户应能够：</p>
<ul>
<li>理解STM32F103C8T6在电机控制中的关键外设（GPIO、TIM）。</li>
<li>掌握电机驱动器的基本原理和使用方法。</li>
<li>实现小车的基本运动控制（前进、后退、转向）。</li>
<li>配置STM32定时器读取编码器数据并计算速度。</li>
<li>理解PID控制算法的原理，并能将其应用于电机速度闭环控制。</li>
<li>初步掌握PID参数的手动整定方法。</li>
</ul>
<h3 id="9-2-完整示例代码结构-概念性"><a href="#9-2-完整示例代码结构-概念性" class="headerlink" title="9.2. 完整示例代码结构 (概念性)"></a>9.2. 完整示例代码结构 (概念性)</h3><p>一个完整的项目代码通常会包含以下模块化的文件结构：</p>
<ul>
<li><code>main.c</code>: 主程序文件，包含初始化调用和主循环。</li>
<li><code>motor_control.h</code> &#x2F; <code>motor_control.c</code>: 包含电机底层控制函数（方向、PWM设置）和高层运动函数（前进、后退等）。</li>
<li><code>encoder.h</code> &#x2F; <code>encoder.c</code>: 包含编码器初始化、数据读取和速度计算相关的函数。</li>
<li><code>pid_controller.h</code> &#x2F; <code>pid_controller.c</code>: 包含PID数据结构定义、PID初始化和PID计算函数。</li>
<li><code>stm32f1xx_it.c</code>: 中断服务程序文件，可能包含用于编码器速度计算或PID控制循环的定时器中断处理函数。</li>
</ul>
<h3 id="9-3-后续增强建议"><a href="#9-3-后续增强建议" class="headerlink" title="9.3. 后续增强建议"></a>9.3. 后续增强建议</h3><p>本项目为更复杂的机器人应用奠定了坚实的基础。以下是一些可能的后续增强方向：</p>
<ul>
<li><strong>避障功能：</strong> 集成超声波传感器或红外传感器，实现障碍物检测和规避。</li>
<li><strong>循迹功能：</strong> 使用红外反射传感器阵列，使小车能够沿着预设的黑线或白线行驶。</li>
<li><strong>精确转向控制：</strong> 利用编码器反馈，实现基于特定角度或半径的精确转弯 5。</li>
<li><strong>IMU（惯性测量单元）集成：</strong> 加入陀螺仪和加速度计，用于获取小车的姿态信息（俯仰、滚转、偏航），可用于更稳定的运动控制或平衡机器人等应用。</li>
<li><strong>无线遥控：</strong> 通过蓝牙模块（如HC-05&#x2F;06）或Wi-Fi模块（如ESP8266&#x2F;ESP32）实现对小车的远程控制。</li>
<li><strong>SLAM（即时定位与地图构建）：</strong> 对于更高级的自主导航，可以探索SLAM算法的实现（这通常需要更强大的处理器和更复杂的传感器）。</li>
</ul>
<p>通过本项目所学习到的微控制器编程、传感器集成和控制理论知识，具有高度的可迁移性，能够为开发者在机器人技术及相关嵌入式系统领域的深入探索提供有力支持。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/05/30/%E5%A4%A7%E8%8B%B1%E8%AF%BE%E6%96%87/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/05/30/%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8date-2025-01-01-18-00-00tags-STM32-%E4%BA%BA%E4%BA%BA%E5%8D%93%E8%B6%8Acategories-%E6%9D%82%E7%89%A9"><span class="nav-number">1.</span> <span class="nav-text">title: 电机驱动date: 2025-01-01 18:00:00tags:  - STM32  - 人人卓越categories:  - 杂物</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESTM32F103C8T6%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%BD%A6%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E4%B8%8EPID%E6%8E%A7%E5%88%B6%E8%AE%BE%E8%AE%A1"><span class="nav-number"></span> <span class="nav-text">基于STM32F103C8T6的机器人小车电机驱动与PID控制设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC1%E8%8A%82%EF%BC%9ASTM32F103C8T6%E4%B8%8E%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%BD%A6%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">第1节：STM32F103C8T6与机器人小车电机控制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-STM32F103C8T6%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A6%82%E8%A7%88"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. STM32F103C8T6微控制器概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B7%AE%E9%80%9F%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%BD%A6"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 差速驱动机器人小车</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. 电机驱动器的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC2%E8%8A%82%EF%BC%9A%E7%A1%AC%E4%BB%B6%E6%90%AD%E5%BB%BA%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.</span> <span class="nav-text">第2节：硬件搭建与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%80%89%E6%8B%A9%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8IC"><span class="nav-number">2.1.</span> <span class="nav-text">2.1. 选择电机驱动器IC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-L298N%E5%8F%8CH%E6%A1%A5%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1. L298N双H桥电机驱动器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-DRV8833%E5%8F%8CH%E6%A1%A5%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2. DRV8833双H桥电机驱动器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E6%AF%94%E8%BE%83%E4%B8%8E%E6%8E%A8%E8%8D%90"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3. 比较与推荐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E5%9B%BE%EF%BC%9ASTM32F103C8T6%E4%B8%8EL298N%E5%8F%8A%E4%B8%A4%E8%B7%AF%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">2.2. 硬件连接图：STM32F103C8T6与L298N及两路直流电机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%94%B5%E6%BA%90%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.3.</span> <span class="nav-text">2.3. 电源注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%8F%AF%E9%80%89%E4%BD%86PID%E6%8E%A7%E5%88%B6%E6%8E%A8%E8%8D%90-%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">2.4. (可选但PID控制推荐) 旋转编码器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC3%E8%8A%82%EF%BC%9ASTM32CubeIDE%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%85%8D%E7%BD%AE"><span class="nav-number">3.</span> <span class="nav-text">第3节：STM32CubeIDE电机控制配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9C%A8STM32CubeIDE%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%96%B0%E5%B7%A5%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">3.1. 在STM32CubeIDE中设置新工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE"><span class="nav-number">3.2.</span> <span class="nav-text">3.2. 系统时钟配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-L298N%E6%96%B9%E5%90%91%E6%8E%A7%E5%88%B6%E7%9A%84GPIO%E9%85%8D%E7%BD%AE"><span class="nav-number">3.3.</span> <span class="nav-text">3.3. L298N方向控制的GPIO配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-PWM%E9%80%9F%E5%BA%A6%E6%8E%A7%E5%88%B6%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">3.4.</span> <span class="nav-text">3.4. PWM速度控制的定时器配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%A1%A82%EF%BC%9ASTM32F103C8T6%E4%B8%8EL298N%E6%8E%A7%E5%88%B6%E5%BC%95%E8%84%9A%E6%98%A0%E5%B0%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.5.</span> <span class="nav-text">3.5. 表2：STM32F103C8T6与L298N控制引脚映射示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC4%E8%8A%82%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%BD%A6%E5%9F%BA%E6%9C%AC%E8%BF%90%E5%8A%A8-C%E4%BB%A3%E7%A0%81%E4%B8%8EHAL%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">第4节：实现机器人小车基本运动 (C代码与HAL库)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E4%B8%8EHAL%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">4.1. 工程结构与HAL初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%90%AF%E5%8A%A8PWM%E4%BF%A1%E5%8F%B7"><span class="nav-number">4.2.</span> <span class="nav-text">4.2. 启动PWM信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%AE%9A%E4%B9%89%E7%94%B5%E6%9C%BA%E5%92%8C%E6%96%B9%E5%90%91%E7%B1%BB%E5%9E%8B-%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.3.</span> <span class="nav-text">4.3. 定义电机和方向类型 (示例)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%BA%95%E5%B1%82%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">4.4. 底层电机控制函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E8%AE%BE%E7%BD%AE%E7%94%B5%E6%9C%BAPWM%E9%80%9F%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1. 设置电机PWM速度函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-L298N%E7%94%B5%E6%9C%BA%E6%96%B9%E5%90%91%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2. L298N电机方向控制函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E9%AB%98%E5%B1%82%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">4.5. 高层机器人运动函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%B5%8B%E8%AF%95"><span class="nav-number">4.6.</span> <span class="nav-text">4.6. 主循环测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC5%E8%8A%82%EF%BC%9APID%E6%8E%A7%E5%88%B6%E5%A2%9E%E5%BC%BA%E6%80%A7%E8%83%BD%E7%AE%80%E4%BB%8B"><span class="nav-number">5.</span> <span class="nav-text">第5节：PID控制增强性能简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81PID%EF%BC%9F%E5%BC%80%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">5.1. 为何需要PID？开环控制的局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-PID%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA%E8%A7%A3%E9%87%8A"><span class="nav-number">5.2.</span> <span class="nav-text">5.2. PID基本理论解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%8F%8D%E9%A6%88%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%EF%BC%9A%E5%BC%95%E5%85%A5%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">5.3. 反馈的必要性：引入编码器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC6%E8%8A%82%EF%BC%9ASTM32F103C8T6%E9%9B%86%E6%88%90%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">第6节：STM32F103C8T6集成编码器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%90%86%E8%A7%A3%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">6.1.</span> <span class="nav-text">6.1. 理解正交编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E9%85%8D%E7%BD%AESTM32%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">6.2. 配置STM32定时器的编码器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E8%AF%BB%E5%8F%96%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%95%B0%E5%B9%B6%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6"><span class="nav-number">6.3.</span> <span class="nav-text">6.3. 读取编码器计数并计算速度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E8%AF%BB%E5%8F%96%E5%8E%9F%E5%A7%8B%E8%AE%A1%E6%95%B0%E5%80%BC"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1. 读取原始计数值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6-%E4%BE%8B%E5%A6%82%EF%BC%8C%E6%AF%8F%E9%87%87%E6%A0%B7%E6%97%B6%E9%97%B4%E7%9A%84%E8%84%89%E5%86%B2%E6%95%B0%E6%88%96RPM"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2. 计算速度 (例如，每采样时间的脉冲数或RPM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B-%E7%BC%96%E7%A0%81%E5%99%A8%E8%AF%BB%E5%8F%96%E4%B8%8E%E9%80%9F%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3. C代码结构示例 (编码器读取与速度计算)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC7%E8%8A%82%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%94%B5%E6%9C%BAPID%E9%80%9F%E5%BA%A6%E6%8E%A7%E5%88%B6-C%E4%BB%A3%E7%A0%81%E4%B8%8EHAL%E5%BA%93"><span class="nav-number">7.</span> <span class="nav-text">第7节：实现电机PID速度控制 (C代码与HAL库)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-PID%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">7.1. PID数据结构定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-PID%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0-pid-init"><span class="nav-number">7.2.</span> <span class="nav-text">7.2. PID初始化函数 pid_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-PID%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0-pid-compute"><span class="nav-number">7.3.</span> <span class="nav-text">7.3. PID计算函数 pid_compute()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E5%B0%86PID%E8%BE%93%E5%87%BA%E5%BA%94%E7%94%A8%E4%BA%8EPWM%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="nav-number">7.4.</span> <span class="nav-text">7.4. 将PID输出应用于PWM占空比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E5%B8%A6PID%E7%9A%84%E4%B8%BB%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">7.5.</span> <span class="nav-text">7.5. 带PID的主控制循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC8%E8%8A%82%EF%BC%9APID%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8F%82%E6%95%B0%E6%95%B4%E5%AE%9A"><span class="nav-number">8.</span> <span class="nav-text">第8节：PID控制器参数整定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E6%95%B4%E5%AE%9A%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">8.1.</span> <span class="nav-text">8.1. 整定的目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E6%89%8B%E5%8A%A8%E6%95%B4%E5%AE%9A%E6%96%B9%E6%B3%95-%E8%AF%95%E5%87%91%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">8.2. 手动整定方法 (试凑法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-Kp%E2%80%8B-Ki%E2%80%8B-Kd%E2%80%8B%E5%AF%B9%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">8.3.</span> <span class="nav-text">8.3. Kp​,Ki​,Kd​对系统响应的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B0%8F%E8%BD%A6PID%E6%95%B4%E5%AE%9A%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-number">8.4.</span> <span class="nav-text">8.4. 机器人小车PID整定实用技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-Ziegler-Nichols%E6%95%B4%E5%AE%9A%E6%B3%95-%E7%AE%80%E8%BF%B0"><span class="nav-number">8.5.</span> <span class="nav-text">8.5. Ziegler-Nichols整定法 (简述)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC9%E8%8A%82%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="nav-number">9.</span> <span class="nav-text">第9节：总结与展望</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E6%88%90%E6%9E%9C%E6%80%BB%E7%BB%93"><span class="nav-number">9.1.</span> <span class="nav-text">9.1. 成果总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84-%E6%A6%82%E5%BF%B5%E6%80%A7"><span class="nav-number">9.2.</span> <span class="nav-text">9.2. 完整示例代码结构 (概念性)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E5%90%8E%E7%BB%AD%E5%A2%9E%E5%BC%BA%E5%BB%BA%E8%AE%AE"><span class="nav-number">9.3.</span> <span class="nav-text">9.3. 后续增强建议</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="St_w"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">St_w</p>
  <div class="site-description" itemprop="description">老大，欢迎回来喵~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Fri May 30 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">St_w</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















    <div id="pjax">
  

  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

    </div>
</body>
</html>
