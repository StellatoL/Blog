<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="好的，这是一个《视频编码标准及其算法原理》的大作业。我会针对你提出的每一项任务要求，提供详细的步骤、原理、公式，并指出在MATLAB中可能用到的函数或方法。 请注意： 由于我无法直接访问你的图像帧F1和F2，也无法执行MATLAB代码，因此我将提供的是一个框架和原理性的指导。你需要准备好你的图像数据，并根据这些指导在MATLAB中实现具体的代码。  1. 任务要求：使用matlab完成所有流程 这">
<meta property="og:type" content="article">
<meta property="og:title" content="视频编码大作业">
<meta property="og:url" content="http://example.com/2025/01/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%A4%A7%E4%BD%9C%E4%B8%9A/index.html">
<meta property="og:site_name" content="Stellato的星空">
<meta property="og:description" content="好的，这是一个《视频编码标准及其算法原理》的大作业。我会针对你提出的每一项任务要求，提供详细的步骤、原理、公式，并指出在MATLAB中可能用到的函数或方法。 请注意： 由于我无法直接访问你的图像帧F1和F2，也无法执行MATLAB代码，因此我将提供的是一个框架和原理性的指导。你需要准备好你的图像数据，并根据这些指导在MATLAB中实现具体的代码。  1. 任务要求：使用matlab完成所有流程 这">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-01T10:00:00.000Z">
<meta property="article:modified_time" content="2025-05-31T05:16:07.765Z">
<meta property="article:author" content="St_w">
<meta property="article:tag" content="视频编码">
<meta property="article:tag" content="MATLAB">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/01/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%A4%A7%E4%BD%9C%E4%B8%9A/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>视频编码大作业 | Stellato的星空</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Stellato的星空</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%A4%A7%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="St_w">
      <meta itemprop="description" content="老大，欢迎回来喵~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stellato的星空">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          视频编码大作业
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-01 18:00:00" itemprop="dateCreated datePublished" datetime="2025-01-01T18:00:00+08:00">2025-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 13:16:07" itemprop="dateModified" datetime="2025-05-31T13:16:07+08:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E7%89%A9/" itemprop="url" rel="index"><span itemprop="name">杂物</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>好的，这是一个《视频编码标准及其算法原理》的大作业。我会针对你提出的每一项任务要求，提供详细的步骤、原理、公式，并指出在MATLAB中可能用到的函数或方法。</p>
<p><strong>请注意：</strong> 由于我无法直接访问你的图像帧F1和F2，也无法执行MATLAB代码，因此我将提供的是一个框架和原理性的指导。你需要准备好你的图像数据，并根据这些指导在MATLAB中实现具体的代码。</p>
<hr>
<p><strong>1. 任务要求：使用matlab完成所有流程</strong></p>
<p>这表示所有后续步骤的计算、变换、编码等都需要你通过编写MATLAB脚本来实现。</p>
<hr>
<p><strong>2. 对帧F1进行JPEG编码（帧内编码）</strong> 利用matlab实现JPEG的编码和解码重建第一帧F1’，并计算重建图像帧和原始帧F1之间的峰值信噪比PSNR。</p>
<p><strong>JPEG编码流程概述：</strong></p>
<ol>
<li><strong>颜色空间转换（可选）：</strong> 如果是彩色图像，通常从RGB转换到YCbCr。对亮度(Y)和色度(Cb, Cr)分量分别处理。为了简化，我们假设F1是灰度图，或者我们只处理亮度分量。</li>
<li><strong>分块：</strong> 将图像分成8x8的像素块。</li>
<li><strong>离散余弦变换 (DCT)：</strong> 对每个8x8块进行2D-DCT。</li>
<li><strong>量化：</strong> 对DCT系数进行量化，使用标准的量化表。</li>
<li><strong>Zigzag扫描：</strong> 将量化后的2D系数矩阵转换为1D序列。</li>
<li><strong>熵编码：</strong><ul>
<li><strong>DC系数编码：</strong> 对DC系数（每个块的第一个系数，代表平均亮度）进行差分脉冲编码调制 (DPCM)，然后对差值进行熵编码（通常是霍夫曼编码）。</li>
<li><strong>AC系数编码：</strong> 对AC系数（块内其余63个系数）进行游程编码 (RLE)，然后对(run, level)对进行熵编码（通常是霍夫曼编码）。</li>
</ul>
</li>
<li><strong>码流组合：</strong> 将编码后的数据组合成最终的JPEG码流。</li>
</ol>
<p><strong>JPEG解码流程概述：</strong></p>
<ol>
<li><strong>熵解码：</strong> 解码DC和AC系数。</li>
<li><strong>反Zigzag扫描：</strong> 将1D序列恢复成8x8的量化系数矩阵。</li>
<li><strong>反量化：</strong> 对量化系数进行反量化。</li>
<li><strong>反离散余弦变换 (IDCT)：</strong> 对每个块进行2D-IDCT。</li>
<li><strong>图像重建：</strong> 将处理后的8x8块拼接成重建图像。</li>
<li><strong>颜色空间反转换（可选）：</strong> 如果初始进行了转换，则从YCbCr转回RGB。</li>
</ol>
<p><strong>MATLAB 实现步骤 (以灰度图为例):</strong></p>
<ul>
<li><p><strong>读取图像F1：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F1 = imread(&#x27;your_frame_F1.png&#x27;); % 假设是png格式，替换为你的文件名</span><br><span class="line">if size(F1, 3) == 3</span><br><span class="line">    F1_gray = rgb2gray(F1); % 如果是彩色图，转为灰度图</span><br><span class="line">else</span><br><span class="line">    F1_gray = F1;</span><br><span class="line">end</span><br><span class="line">F1_double = double(F1_gray); % 转换为double类型方便计算</span><br><span class="line">[rows, cols] = size(F1_double);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JPEG编码 (简化版，主要关注DCT、量化、反量化、IDCT):</strong></p>
<ul>
<li><p><strong>定义8x8块处理函数 (编码):</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% 标准亮度量化表 (来自JPEG K.1)</span><br><span class="line">Q_lum = [16 11 10 16 24 40 51 61;</span><br><span class="line">         12 12 14 19 26 58 60 55;</span><br><span class="line">         14 13 16 24 40 57 69 56;</span><br><span class="line">         14 17 22 29 51 87 80 62;</span><br><span class="line">         18 22 37 56 68 109 103 77;</span><br><span class="line">         24 35 55 64 81 104 113 92;</span><br><span class="line">         49 64 78 87 103 121 120 101;</span><br><span class="line">         72 92 95 98 112 100 103 99];</span><br><span class="line"></span><br><span class="line">dct_func = @(block_struct) dct2(block_struct.data - 128); % DCT，减128使像素值中心化</span><br><span class="line">quant_func = @(block_struct) round(block_struct.data ./ Q_lum); % 量化</span><br><span class="line"></span><br><span class="line">% 对F1_double进行分块DCT和量化</span><br><span class="line">F1_dct_quant = blockproc(F1_double, [8 8], dct_func);</span><br><span class="line">F1_quantized = blockproc(F1_dct_quant, [8 8], quant_func);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JPEG解码 (简化版):</strong></p>
<ul>
<li><strong>定义8x8块处理函数 (解码):</strong></li>
</ul>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dequant_func = @(block_struct) block_struct.data .* Q_lum; % 反量化</span><br><span class="line">idct_func = @(block_struct) idct2(block_struct.data) + 128; % IDCT，加128恢复</span><br><span class="line"></span><br><span class="line">% 对量化系数进行反量化和IDCT</span><br><span class="line">F1_dequant = blockproc(F1_quantized, [8 8], dequant_func);</span><br><span class="line">F1_reconstructed_double = blockproc(F1_dequant, [8 8], idct_func);</span><br><span class="line">F1_prime = uint8(F1_reconstructed_double); % 转回uint8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong> 上述简化版省略了熵编码部分，因为完整的熵编码比较复杂。对于作业，你可能需要更详细地实现Zigzag扫描和基于霍夫曼表的编码，或者根据老师要求明确是否需要完整熵编码。</p>
</li>
</ul>
</li>
<li><p><strong>计算PSNR：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mse = mean((F1_double(:) - F1_reconstructed_double(:)).^2);</span><br><span class="line">if mse == 0</span><br><span class="line">    psnr_val = Inf;</span><br><span class="line">else</span><br><span class="line">    max_pixel_val = 255; % 假设8位图像</span><br><span class="line">    psnr_val = 10 * log10(max_pixel_val^2 / mse);</span><br><span class="line">end</span><br><span class="line">fprintf(&#x27;PSNR between F1 and F1_prime: %.2f dB\n&#x27;, psnr_val);</span><br><span class="line"></span><br><span class="line">% 显示图像 (可选)</span><br><span class="line">% figure;</span><br><span class="line">% subplot(1,2,1); imshow(F1_gray); title(&#x27;Original F1&#x27;);</span><br><span class="line">% subplot(1,2,2); imshow(F1_prime); title(&#x27;Reconstructed F1&#x27;&#x27;&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>3. 从F1中任选一个8*8的块B1，给出以下详细过程</strong></p>
<p>假设你已经从<code>F1_double</code>中选择了一个8x8的块 <code>B1</code>。</p>
<p>Matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 假设你选择的是F1左上角的第一个8x8块</span><br><span class="line">B1 = F1_double(1:8, 1:8);</span><br></pre></td></tr></table></figure>

<p><strong>3.1 给出该块的8*8矩阵形式：</strong></p>
<p>Matlab</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;3.1 Block B1 (8x8 matrix):&#x27;);</span><br><span class="line">disp(B1);</span><br></pre></td></tr></table></figure>

<p>这里会直接打印出你选定的<code>B1</code>矩阵。</p>
<p><strong>3.2 对块B1进行二维DCT变换，可以借助matlab计算得到。给出变换公式和变换系数块：</strong></p>
<ul>
<li><p><strong>二维DCT变换公式：</strong> 对于一个 N×N 的块 f(x,y)，其2D-DCT系数 F(u,v) 计算如下： F(u,v)&#x3D;C(u)C(v)x&#x3D;0∑N−1​y&#x3D;0∑N−1​f(x,y)cos[2N(2x+1)uπ​]cos[2N(2y+1)vπ​] 其中 u,v&#x3D;0,1,…,N−1，且 C(k)&#x3D;{1&#x2F;N![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
  c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
  c340,-704.7,510.7,-1060.3,512,-1067
  l0 -0
  c4.7,-7.3,11,-11,19,-11
  H40000v40H1012.3
  s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
  c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
  s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
  c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
  M1001 80h400000v40h-400000z"></path></svg>)​2&#x2F;N![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
  c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
  c340,-704.7,510.7,-1060.3,512,-1067
  l0 -0
  c4.7,-7.3,11,-11,19,-11
  H40000v40H1012.3
  s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
  c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
  s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
  c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
  M1001 80h400000v40h-400000z"></path></svg>)​​if k&#x3D;0if k&gt;0​ 对于JPEG，通常先将像素值 f(x,y) 减去 2P−1 (例如，对于8位图像，P&#x3D;8，减去128)。</p>
</li>
<li><p><strong>MATLAB计算：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B1_centered = B1 - 128; % 中心化</span><br><span class="line">B1_dct = dct2(B1_centered);</span><br><span class="line"></span><br><span class="line">disp(&#x27;3.2 DCT Transform Coefficients for B1:&#x27;);</span><br><span class="line">disp(B1_dct);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.3 对变换系数块进行量化</strong> 从jpeg标准文档Table K.1 – Luminance quantization table获取亮度分量的量化矩阵。给出量化过程的公式及量化后的系数矩阵：</p>
<ul>
<li><p><strong>亮度分量量化矩阵 (Table K.1)：</strong> (已在上面给出)</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q_lum = [16 11 10 16 24 40 51 61;</span><br><span class="line">         12 12 14 19 26 58 60 55;</span><br><span class="line">         14 13 16 24 40 57 69 56;</span><br><span class="line">         14 17 22 29 51 87 80 62;</span><br><span class="line">         18 22 37 56 68 109 103 77;</span><br><span class="line">         24 35 55 64 81 104 113 92;</span><br><span class="line">         49 64 78 87 103 121 120 101;</span><br><span class="line">         72 92 95 98 112 100 103 99];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>量化过程公式：</strong> 对于DCT系数矩阵 F(u,v) 和量化矩阵 Q(u,v)，量化后的系数 Fq​(u,v) 为： Fq​(u,v)&#x3D;round(Q(u,v)F(u,v)​)</p>
</li>
<li><p><strong>MATLAB计算：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B1_quantized = round(B1_dct ./ Q_lum);</span><br><span class="line"></span><br><span class="line">disp(&#x27;3.3 Quantized DCT Coefficients for B1:&#x27;);</span><br><span class="line">disp(B1_quantized);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.4 对量化系数矩阵进行Z形扫描，得到一维序列:</strong></p>
<ul>
<li><p><strong>Z形扫描顺序：</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0  1  5  6 14 15 27 28</span><br><span class="line">2  4  7 13 16 26 29 42</span><br><span class="line">3  8 12 17 25 30 41 43</span><br><span class="line">9 11 18 24 31 40 44 53</span><br><span class="line">10 19 23 32 39 45 52 54</span><br><span class="line">20 22 33 38 46 51 55 60</span><br><span class="line">21 34 37 47 50 56 59 61</span><br><span class="line">35 36 48 49 57 58 62 63</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MATLAB实现 (需要一个辅助函数)：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">% Zigzag scan order for 8x8 block</span><br><span class="line">zigzag_order = [</span><br><span class="line">     0  1  5  6 14 15 27 28</span><br><span class="line">     2  4  7 13 16 26 29 42</span><br><span class="line">     3  8 12 17 25 30 41 43</span><br><span class="line">     9 11 18 24 31 40 44 53</span><br><span class="line">    10 19 23 32 39 45 52 54</span><br><span class="line">    20 22 33 38 46 51 55 60</span><br><span class="line">    21 34 37 47 50 56 59 61</span><br><span class="line">    35 36 48 49 57 58 62 63</span><br><span class="line">] + 1; % MATLAB is 1-indexed</span><br><span class="line"></span><br><span class="line">B1_zigzag_scanned = zeros(1, 64);</span><br><span class="line">temp_B1_quantized = B1_quantized&#x27;; % Transpose for column-major zigzag_order scan</span><br><span class="line">for i = 1:64</span><br><span class="line">    B1_zigzag_scanned(i) = temp_B1_quantized(zigzag_order(i));</span><br><span class="line">end</span><br><span class="line">% A more robust way to implement zigzag:</span><br><span class="line">% (You can find many zigzag scan functions for MATLAB online)</span><br><span class="line">% For example:</span><br><span class="line">% function output = zigzag(input)</span><br><span class="line">%     [m, n] = size(input);</span><br><span class="line">%     output = zeros(1, m*n);</span><br><span class="line">%     count = 1;</span><br><span class="line">%     for s = 1:(m+n-1)</span><br><span class="line">%         if mod(s, 2) == 1 % Odd sum: up-right</span><br><span class="line">%             for i = max(1, s-n+1):min(s, m)</span><br><span class="line">%                 j = s - i + 1;</span><br><span class="line">%                 output(count) = input(i, j);</span><br><span class="line">%                 count = count + 1;</span><br><span class="line">%             end</span><br><span class="line">%         else % Even sum: down-left</span><br><span class="line">%             for j = max(1, s-m+1):min(s, n)</span><br><span class="line">%                 i = s - j + 1;</span><br><span class="line">%                 output(count) = input(i, j);</span><br><span class="line">%                 count = count + 1;</span><br><span class="line">%             end</span><br><span class="line">%         end</span><br><span class="line">%     end</span><br><span class="line">% end</span><br><span class="line">% B1_zigzag_scanned = zigzag(B1_quantized);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">disp(&#x27;3.4 Zigzag Scanned 1D Sequence:&#x27;);</span><br><span class="line">disp(B1_zigzag_scanned);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.5 对一维序列进行熵编码，包括给出中间符号1和中间符号2，最后给出该块的码流：</strong> （可能需要用到JPEG标准文档…Table K.3 – Table for luminance DC coefficient differences，Table K.5 – Table for luminance AC coefficients。）</p>
<p>这部分是JPEG编码中最复杂的部分之一，涉及到差分编码、游程编码和霍夫曼编码。 你需要JPEG标准文档中定义的霍夫曼表（K.3, K.4, K.5, K.6）。通常这些表是固定的，或者在JPEG文件头中指定。</p>
<ul>
<li><p><strong>DC系数编码：</strong></p>
<ol>
<li><strong>差分编码 (DPCM):</strong> 第一个块的DC系数直接编码。后续块的DC系数是当前块DC与前一个块DC的差值 (DIFFERENCE &#x3D; DC_current - DC_previous)。 <code>DC_coeff = B1_zigzag_scanned(1);</code> <code>DIFFERENCE = DC_coeff - Previous_DC;</code> (假设<code>Previous_DC</code>是前一个块的DC，对第一个块，<code>Previous_DC = 0</code>)</li>
<li><strong>确定类别 (Category&#x2F;SSSS):</strong> 根据DIFFERENCE的值，查Table K.3（亮度DC系数差值表）确定其类别 (SSSS)。</li>
<li><strong>确定幅值 (Magnitude&#x2F;ZZZZ…):</strong> 对于非零DIFFERENCE，其二进制表示（如果为负，则为其绝对值的反码）是幅值。</li>
<li><strong>霍夫曼编码：</strong><ul>
<li>类别的霍夫曼码 (from Table K.3, Luminance DC Huffman Code Table)。</li>
<li>幅值的二进制码。</li>
<li><strong>中间符号1 (DC):</strong> (Category, Magnitude_Code)</li>
<li><strong>码流 (DC):</strong> HuffmanCode(Category) || Magnitude_Code</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>AC系数编码：</strong></p>
<ol>
<li><strong>游程编码 (RLE):</strong> 从Zigzag序列的第二个系数开始，扫描AC系数。<ul>
<li>统计连续的0的个数 (RUNLENGTH&#x2F;RRRR)。</li>
<li>下一个非零系数的值 (LEVEL&#x2F;VALUE)。</li>
<li><strong>特殊符号：</strong><ul>
<li>EOB (End of Block): 如果剩下的AC系数都是0，则用一个特殊码 (通常是 (0,0) )表示。</li>
<li>ZRL (Zero Run Length): 如果有超过15个连续的0，则用一个特殊码 (通常是 (15,0) )表示16个0，然后继续计数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>确定 (RUNLENGTH, SIZE) 对：</strong><ul>
<li>RUNLENGTH: 连续0的个数 (0-15)。</li>
<li>SIZE (or Category): 非零AC系数的幅值类别 (类似于DC系数的SSSS，但查AC系数的表)。</li>
</ul>
</li>
<li><strong>确定幅值 (Magnitude&#x2F;ZZZZ…):</strong> 非零AC系数的二进制表示。</li>
<li><strong>霍夫MAN编码：</strong><ul>
<li>(RUNLENGTH, SIZE)对的霍夫曼码 (from Table K.5, Luminance AC Huffman Code Table)。</li>
<li>幅值的二进制码。</li>
<li><strong>中间符号2 (AC):</strong> (Run, Size), Magnitude_Code</li>
<li><strong>码流 (AC):</strong> HuffmanCode(Run, Size) || Magnitude_Code</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>示例 (概念性):</strong> 假设 <code>B1_zigzag_scanned = [52, -5, 0, 3, -2, 0, 0, 1, EOB, ...]</code> (EOB代表后面都是0) 假设 <code>Previous_DC = 40</code></p>
<ul>
<li><p><strong>DC系数:</strong> <code>DC_coeff = 52</code> <code>DIFFERENCE = 52 - 40 = 12</code> 查Table K.3: 12属于类别4 (SSSS&#x3D;4)。幅值码是 ‘1100’。 假设类别4的霍夫曼码是 ‘100’ (查表)。 DC码流: ‘100’ + ‘1100’ &#x3D; ‘1001100’</p>
</li>
<li><p><strong>AC系数:</strong></p>
<ol>
<li><code>-5</code>: RUNLENGTH&#x3D;0. <code>-5</code> 属于类别3 (SIZE&#x3D;3)。幅值码是 ‘010’ (5的反码是…1010，取后3位)。 假设 (0,3) 的霍夫曼码是 ‘01’ (查Table K.5)。 AC码流1: ‘01’ + ‘010’ &#x3D; ‘01010’</li>
<li><code>0, 3</code>: RUNLENGTH&#x3D;1. <code>3</code> 属于类别2 (SIZE&#x3D;2). 幅值码是 ‘11’. 假设 (1,2) 的霍夫曼码是 ‘11010’ (查Table K.5)。 AC码流2: ‘11010’ + ‘11’ &#x3D; ‘1101011’</li>
<li><code>-2</code>: RUNLENGTH&#x3D;0. <code>-2</code> 属于类别2 (SIZE&#x3D;2). 幅值码是 ‘01’. 假设 (0,2) 的霍夫曼码是 ‘00’ (查Table K.5)。 AC码流3: ‘00’ + ‘01’ &#x3D; ‘0001’</li>
<li><code>0, 0, 1</code>: RUNLENGTH&#x3D;2. <code>1</code> 属于类别1 (SIZE&#x3D;1). 幅值码是 ‘1’. 假设 (2,1) 的霍夫曼码是 ‘11111001’ (查Table K.5)。 AC码流4: ‘11111001’ + ‘1’ &#x3D; ‘111110011’</li>
<li><code>EOB</code>: 假设 EOB (0,0) 的霍夫曼码是 ‘1010’ (查Table K.5)。 AC码流_EOB: ‘1010’</li>
</ol>
</li>
<li><p><strong>该块的总码流 (B1_bitstream):</strong> DC码流 + AC码流1 + AC码流2 + … + AC码流_EOB <code>B1_bitstream = &#39;1001100&#39; + &#39;01010&#39; + &#39;1101011&#39; + &#39;0001&#39; + &#39;111110011&#39; + &#39;1010&#39;</code></p>
</li>
</ul>
<p>  <strong>MATLAB实现提示：</strong> 你需要将JPEG标准中的霍夫曼表（K.3, K.5等）硬编码到你的MATLAB脚本中，通常是以cell数组或结构体的形式存储码字和对应的(类别)或(Run,Size)。然后根据计算出的DIFFERENCE、(RUNLENGTH, SIZE)查找对应的霍夫曼码。</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">% --- DC Coefficient Encoding ---</span><br><span class="line">dc_coeff = B1_zigzag_scanned(1);</span><br><span class="line">% Assume previous_dc_coeff is available (for first block, it&#x27;s 0)</span><br><span class="line">% For simplicity, let&#x27;s assume previous_dc_coeff = 0 for this standalone block example.</span><br><span class="line">% In a real sequence, you&#x27;d track it.</span><br><span class="line">previous_dc_coeff = 0; % Placeholder</span><br><span class="line">diff_dc = dc_coeff - previous_dc_coeff;</span><br><span class="line"></span><br><span class="line">% [dc_category, dc_magnitude_code] = get_dc_category_and_magnitude(diff_dc); % User function</span><br><span class="line">% dc_huffman_code = lookup_dc_huffman_table(dc_category); % User function using Table K.3</span><br><span class="line"></span><br><span class="line">% For example:</span><br><span class="line">% if diff_dc == 0, category = 0, magnitude_code = &#x27;&#x27;</span><br><span class="line">% if diff_dc &gt; 0, category = floor(log2(diff_dc)) + 1, magnitude_code = dec2bin(diff_dc)</span><br><span class="line">% if diff_dc &lt; 0, category = floor(log2(abs(diff_dc))) + 1, magnitude_code = dec2bin(bitcmp(uint16(abs(diff_dc)), category)) % Be careful with negative num representation</span><br><span class="line"></span><br><span class="line">% disp([&#x27;DC diff: &#x27;, num2str(diff_dc)]);</span><br><span class="line">% disp([&#x27;DC Category (SSSS): &#x27;, num2str(dc_category)]); % Intermediate Symbol 1 (part 1)</span><br><span class="line">% disp([&#x27;DC Magnitude Code: &#x27;, dc_magnitude_code]);     % Intermediate Symbol 1 (part 2)</span><br><span class="line">% disp([&#x27;DC Huffman Code: &#x27;, dc_huffman_code]);</span><br><span class="line">% block_bitstream = dc_huffman_code;</span><br><span class="line">% block_bitstream = [block_bitstream, dc_magnitude_code];</span><br><span class="line"></span><br><span class="line">% --- AC Coefficient Encoding ---</span><br><span class="line">ac_coeffs = B1_zigzag_scanned(2:end);</span><br><span class="line">run_length = 0;</span><br><span class="line">% ac_bitstream_part = &#x27;&#x27;;</span><br><span class="line">% for i = 1:length(ac_coeffs)</span><br><span class="line">%     if ac_coeffs(i) == 0</span><br><span class="line">%         run_length = run_length + 1;</span><br><span class="line">%         if run_length == 16 % ZRL</span><br><span class="line">%             % [ac_huff_code_zrl] = lookup_ac_huffman_table(15, 0); % (15,0) for ZRL from Table K.5</span><br><span class="line">%             % ac_bitstream_part = [ac_bitstream_part, ac_huff_code_zrl];</span><br><span class="line">%             run_length = 0;</span><br><span class="line">%         end</span><br><span class="line">%     else % Non-zero AC coefficient</span><br><span class="line">%         level = ac_coeffs(i);</span><br><span class="line">%         % [ac_size, ac_magnitude_code] = get_ac_size_and_magnitude(level); % User function</span><br><span class="line">%         % [ac_huff_code] = lookup_ac_huffman_table(run_length, ac_size); % User function from Table K.5</span><br><span class="line">%</span><br><span class="line">%         % disp([&#x27;AC (Run, Size): (&#x27;, num2str(run_length), &#x27;,&#x27;, num2str(ac_size), &#x27;)&#x27;]); % Intermediate Symbol 2 (part 1)</span><br><span class="line">%         % disp([&#x27;AC Magnitude Code: &#x27;, ac_magnitude_code]); % Intermediate Symbol 2 (part 2)</span><br><span class="line">%         % disp([&#x27;AC Huffman Code for (Run,Size): &#x27;, ac_huff_code]);</span><br><span class="line">%</span><br><span class="line">%         % ac_bitstream_part = [ac_bitstream_part, ac_huff_code, ac_magnitude_code];</span><br><span class="line">%         run_length = 0;</span><br><span class="line">%     end</span><br><span class="line">% end</span><br><span class="line">% If last coefficient was zero or loop finishes, add EOB</span><br><span class="line">% [ac_huff_code_eob] = lookup_ac_huffman_table(0, 0); % (0,0) for EOB from Table K.5</span><br><span class="line">% ac_bitstream_part = [ac_bitstream_part, ac_huff_code_eob];</span><br><span class="line">% block_bitstream = [block_bitstream, ac_bitstream_part];</span><br><span class="line"></span><br><span class="line">disp(&#x27;3.5 Entropy Coding:&#x27;);</span><br><span class="line">disp(&#x27;Due to complexity, a full Huffman coding implementation is omitted here.&#x27;);</span><br><span class="line">disp(&#x27;You need to implement Huffman table lookups for DC (Table K.3) and AC (Table K.5).&#x27;);</span><br><span class="line">disp(&#x27;Intermediate Symbol 1 (DC): (Category, Magnitude_Code)&#x27;);</span><br><span class="line">disp(&#x27;Intermediate Symbol 2 (AC): (Run, Size), Magnitude_Code&#x27;);</span><br><span class="line">disp(&#x27;Final Bitstream for B1: Concatenation of Huffman codes and magnitude codes.&#x27;);</span><br><span class="line">% disp([&#x27;Example B1 bitstream (conceptual): &#x27;, block_bitstream]);</span><br></pre></td></tr></table></figure>
<p>  <strong>重要提示：</strong> 实现完整的JPEG熵编码（特别是查表和构造码流）是相当细致的工作。你需要非常仔细地参照JPEG标准文档中的附录K。</p>
</li>
</ul>
<hr>
<p><strong>4. 对F2进行帧间编码（以第一帧的重建帧F1’为参考帧）</strong></p>
<p><strong>4.1 运动估计</strong> 在F2中自选一个4*4的块B2，利用全搜索算法进行运动估计，全搜索的matlab代码可在理工智课下载。给出各个搜索点对应的运动矢量MV及其绝对误差和SAE，并确定出最优的运动矢量：</p>
<ul>
<li><p><strong>准备数据：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% 假设F2已读取并转为灰度double</span><br><span class="line">% F2 = imread(&#x27;your_frame_F2.png&#x27;);</span><br><span class="line">% F2_gray = rgb2gray(F2);</span><br><span class="line">% F2_double = double(F2_gray);</span><br><span class="line"></span><br><span class="line">% F1_prime_double = F1_reconstructed_double; % 来自第2步的重建帧</span><br><span class="line"></span><br><span class="line">% 选择F2中的一个4x4块 B2</span><br><span class="line">% 例如，选择F2中 (r_start, c_start) 开始的4x4块</span><br><span class="line">r_start_B2 = 10; c_start_B2 = 10; % 示例坐标</span><br><span class="line">B2 = F2_double(r_start_B2 : r_start_B2+3, c_start_B2 : c_start_B2+3);</span><br><span class="line">disp(&#x27;4.1 Motion Estimation for B2:&#x27;);</span><br><span class="line">disp(&#x27;Selected B2 from F2:&#x27;);</span><br><span class="line">disp(B2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全搜索算法 (Full Search Algorithm):</strong></p>
<ol>
<li><strong>定义搜索窗口：</strong> 在参考帧 <code>F1_prime_double</code> 中，以块 <code>B2</code> 在 <code>F2</code> 中的相同位置为中心，定义一个搜索范围 (e.g., +&#x2F;-7 像素水平和垂直，即15x15的搜索区域)。</li>
<li><strong>遍历搜索点：</strong> 在搜索窗口内，逐个像素移动参考块 (与<code>B2</code>同样大小，4x4)。</li>
<li><strong>计算匹配准则：</strong> 对于每一个搜索到的候选块，与 <code>B2</code> 计算SAD (Sum of Absolute Differences) 或 SAE (Sum of Absolute Errors)。 SAE(dx,dy)&#x3D;∑i&#x3D;0N−1​∑j&#x3D;0M−1​∣B2(i,j)−F1ref′​(i+dx,j+dy)∣ 其中 (dx, dy) 是运动矢量，N&#x3D;4, M&#x3D;4。 F1ref′​(i+dx,j+dy) 是参考帧中对应位置的块。</li>
<li><strong>确定最优运动矢量：</strong> 具有最小SAE的(dx, dy)即为最优运动矢量。</li>
</ol>
</li>
<li><p><strong>MATLAB 实现 (概念，依赖 “理工智课” 的代码或自己实现):</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">search_range = 7; % 例如 +/-7 像素搜索范围</span><br><span class="line">min_sae = inf;</span><br><span class="line">best_mv = [0, 0];</span><br><span class="line">[rows_f1, cols_f1] = size(F1_prime_double);</span><br><span class="line"></span><br><span class="line">disp(&#x27;Search Points, MVs, and SAEs:&#x27;);</span><br><span class="line"></span><br><span class="line">% B2的中心在F1&#x27;中的对应位置</span><br><span class="line">center_r_f1 = r_start_B2;</span><br><span class="line">center_c_f1 = c_start_B2;</span><br><span class="line"></span><br><span class="line">for dy = -search_range : search_range</span><br><span class="line">    for dx = -search_range : search_range</span><br><span class="line">        % 当前搜索的参考块的左上角坐标</span><br><span class="line">        ref_r_start = center_r_f1 + dy;</span><br><span class="line">        ref_c_start = center_c_f1 + dx;</span><br><span class="line"></span><br><span class="line">        % 检查边界</span><br><span class="line">        if (ref_r_start &gt;= 1 &amp;&amp; ref_r_start+3 &lt;= rows_f1 &amp;&amp; ...</span><br><span class="line">            ref_c_start &gt;= 1 &amp;&amp; ref_c_start+3 &lt;= cols_f1)</span><br><span class="line"></span><br><span class="line">            ref_block = F1_prime_double(ref_r_start : ref_r_start+3, ref_c_start : ref_c_start+3);</span><br><span class="line">            current_sae = sum(abs(B2(:) - ref_block(:)));</span><br><span class="line"></span><br><span class="line">            fprintf(&#x27;MV = (%d, %d), SAE = %f\n&#x27;, dx, dy, current_sae);</span><br><span class="line"></span><br><span class="line">            if current_sae &lt; min_sae</span><br><span class="line">                min_sae = current_sae;</span><br><span class="line">                best_mv = [dx, dy]; % 通常MV定义为 (当前帧位置 - 参考帧位置)</span><br><span class="line">                                  % 或者 (参考帧位置 - 当前帧位置)</span><br><span class="line">                                  % 这里 dx, dy 是参考帧相对于当前帧块的偏移</span><br><span class="line">                                  % 如果MV = Pred_pos - Curr_pos, 则 MV = [dx, dy]</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fprintf(&#x27;Optimal Motion Vector (MV_x, MV_y) = (%d, %d) with SAE = %f\n&#x27;, best_mv(1), best_mv(2), min_sae);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4.2 利用运动矢量进行运动补偿后获得帧间预测残差矩阵E（4*4）：</strong></p>
<ul>
<li><p><strong>运动补偿：</strong> 使用找到的最优运动矢量 <code>best_mv</code> 从参考帧 <code>F1_prime_double</code> 中提取预测块 <code>P</code>。</p>
</li>
<li><p><strong>计算残差：</strong> E&#x3D;B2−P</p>
</li>
<li><p><strong>MATLAB 计算：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">predicted_block_r_start = r_start_B2 + best_mv(2); %  MV_y</span><br><span class="line">predicted_block_c_start = c_start_B2 + best_mv(1); %  MV_x</span><br><span class="line"></span><br><span class="line">% 确保预测块在F1&#x27;的边界内</span><br><span class="line">if (predicted_block_r_start &gt;= 1 &amp;&amp; predicted_block_r_start+3 &lt;= rows_f1 &amp;&amp; ...</span><br><span class="line">    predicted_block_c_start &gt;= 1 &amp;&amp; predicted_block_c_start+3 &lt;= cols_f1)</span><br><span class="line">    P_B2 = F1_prime_double(predicted_block_r_start : predicted_block_r_start+3, ...</span><br><span class="line">                           predicted_block_c_start : predicted_block_c_start+3);</span><br><span class="line">else</span><br><span class="line">    % 如果超出边界，通常用边界像素填充或使用一个默认块</span><br><span class="line">    % 为简化，这里假设总在边界内，实际编码器需要处理边界情况</span><br><span class="line">    P_B2 = zeros(4,4); % 或者其他填充策略</span><br><span class="line">    disp(&#x27;Warning: Predicted block for MV is out of F1&#x27;&#x27; bounds. Using zero block for P_B2.&#x27;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">E_B2 = B2 - P_B2; % 残差矩阵</span><br><span class="line"></span><br><span class="line">disp(&#x27;4.2 Inter-prediction Residual Matrix E (4x4):&#x27;);</span><br><span class="line">disp(E_B2);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4.3 对于残差矩阵E进行H.264标准的整数DCT变换和量化，给出逐步计算的结果：</strong></p>
<ul>
<li><p><strong>H.264 4x4 整数变换 (Integer DCT-like transform):</strong> H.264 使用的是一种整数变换，它是DCT的近似，但只使用整数运算。 变换公式: Y&#x3D;Cf​XCfT​ 其中 X 是输入的4x4残差块 EB2​， Cf​ 是变换矩阵： Cf​&#x3D;![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
  c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
  -36,557 l0,1284c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
  949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
  c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
  -544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
  l0,-1292c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
  -210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"></path></svg>)​1211​11−1−2​1−1−12​1−21−1​![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
  63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
  c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1209
  c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
  c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
  c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
  c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
  l0,-1344c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
  -470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"></path></svg>)​ 变换后的系数矩阵 Y 中的元素需要进行后续的缩放（这是H.264变换与量化紧密结合的一部分）。</p>
<p>  一个完整的变换与缩放过程可以表示为 W&#x3D;(Cf​XCfT​)⊗Ef​，其中 ⊗ 是元素 Hadamard 乘积， Ef​ 是一个缩放矩阵： Ef​&#x3D;![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
  c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
  -36,557 l0,1284c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
  949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
  c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
  -544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
  l0,-1292c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
  -210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"></path></svg>)​a2ab&#x2F;2a2ab&#x2F;2​ab&#x2F;2b2&#x2F;4ab&#x2F;2b2&#x2F;4​a2ab&#x2F;2a2ab&#x2F;2​ab&#x2F;2b2&#x2F;4ab&#x2F;2b2&#x2F;4​![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
  63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
  c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1209
  c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
  c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
  c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
  c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
  l0,-1344c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
  -470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"></path></svg>)​ 其中 a&#x3D;1&#x2F;2, b&#x3D;1&#x2F;2![](data:image&#x2F;svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
  c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
  c340,-704.7,510.7,-1060.3,512,-1067
  l0 -0
  c4.7,-7.3,11,-11,19,-11
  H40000v40H1012.3
  s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
  c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
  s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
  c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
  M1001 80h400000v40h-400000z"></path></svg>)​≈0.707 (实际H.264中这些因子被整合到量化步骤的乘法因子和移位中，避免浮点运算)。</p>
<p>  <strong>核心变换 (Forward transform core coefficients):</strong> Yij​&#x3D;∑k​∑l​Cik​Xkl​(CT)lj​ 实际上，H.264标准定义的是整数运算后的系数，然后通过量化参数QP进行量化。</p>
<p>  <strong>简化版整数变换（只考虑核心变换 Y&#x3D;Cf​XCfT​）：</strong></p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cf = [ 1  1  1  1;</span><br><span class="line">       2  1 -1 -2;</span><br><span class="line">       1 -1 -1  1;</span><br><span class="line">       1 -2  2 -1 ];</span><br><span class="line"></span><br><span class="line">Y_B2 = Cf * E_B2 * Cf&#x27;; % 核心变换</span><br><span class="line">disp(&#x27;4.3.1 H.264 Integer Transformed Coefficients (before scaling/quant):&#x27;);</span><br><span class="line">disp(Y_B2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>H.264 量化:</strong> 量化公式 (简化形式，实际更复杂，涉及QP和预计算的乘法因子和移位): Zij​&#x3D;round(Yij​&#x2F;Qstep​) 或者更接近H.264标准的形式（对于帧内预测的亮度残差系数，这里是帧间）： Levelij​&#x3D;(Wij​⋅MFij​+f)&gt;&gt;(qbits+shift) 其中 Wij​ 是变换系数，MFij​ 是量化参数QP相关的乘法因子，f 是加性偏移（用于近似round），<code>&gt;&gt;</code> 是右移。 qbits&#x3D;15+⌊QP&#x2F;6⌋ MF 依赖于 QP(mod6) 和系数位置 (i,j)。</p>
<p>  <strong>为简化演示，我们使用一个非常简化的量化，假设一个 Qstep​:</strong> 你需要选择一个量化参数QP。QP决定了 Qstep​。 例如，对于一个给定的QP，可以有一个对应的 Qstep​。 H.264的量化表和QP到 Qstep​ 的映射比JPEG复杂。 Qstep​ 大约每增加6个QP值就翻倍。</p>
<p>  <strong>一个非常非常简化的例子（不完全符合H.264标准，仅为演示步骤）：</strong> 假设我们选择一个QP，它对应一个 Qstep​。 例如，如果QP&#x3D;26, Qstep​ 可能近似为 10 (这只是一个示意值)。</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">QP = 26; % Example Quantization Parameter</span><br><span class="line">% In H.264, Qstep is derived from QP and coefficient position.</span><br><span class="line">% For this example, let&#x27;s use a placeholder Qstep.</span><br><span class="line">% A rough Qstep might be derived, e.g. Qstep_base * 2^(QP/6).</span><br><span class="line">% Or use pre-defined scaling factors based on QP % 6 and QP / 6.</span><br><span class="line"></span><br><span class="line">% H.264 has 6 quantization scaling factors for each QP/6 level (V[][])</span><br><span class="line">% and a scaling factor based on QP%6 (PF[][])</span><br><span class="line">% LevelScale( qP, i, j ) = PF[qP%6][(i*4+j)% ( (i==0||i==2)&amp;&amp;(j==0||j==2) ? 3:1 ) ] &lt;&lt; (qP/6)</span><br><span class="line">% QuantizedCoeff = sign(TransformedCoeff) * ( abs(TransformedCoeff) * V[qP%6][(i*4+j)%...] + offset ) &gt;&gt; ( 15 + qP/6 )</span><br><span class="line"></span><br><span class="line">% Simplified Quantization (conceptual for assignment unless deep dive required)</span><br><span class="line">% This does NOT reflect the full H.264 quantization.</span><br><span class="line">% The true H.264 quantization is:</span><br><span class="line">% Z_ij = sign(Y_ij) * (|Y_ij| * MF + f) &gt;&gt; (15 + floor(QP/6))</span><br><span class="line">% where MF depends on QP%6 and coefficient position (i,j) from a table,</span><br><span class="line">% f is an offset (e.g., 2^(14+floor(QP/6)) for intra, smaller for inter)</span><br><span class="line"></span><br><span class="line">% Let&#x27;s create a placeholder quantization matrix based on QP for demonstration</span><br><span class="line">% This is NOT standard but illustrates the step.</span><br><span class="line">% The actual MF values are in tables like Table 7-9 in H.264 spec.</span><br><span class="line">% For simplicity, let&#x27;s use a flat Qstep, which is a gross simplification.</span><br><span class="line">Qstep_example = 10 * (2^(QP/6 - 4)); % Very rough illustrative Qstep</span><br><span class="line"></span><br><span class="line">E_B2_quantized = round(Y_B2 / Qstep_example);</span><br><span class="line"></span><br><span class="line">disp([&#x27;4.3.2 H.264 Quantized Coefficients (using QP=&#x27;, num2str(QP), &#x27; and simplified Qstep=&#x27;, num2str(Qstep_example), &#x27;):&#x27;]);</span><br><span class="line">disp(E_B2_quantized);</span><br><span class="line"></span><br><span class="line">disp(&#x27;NOTE: The H.264 quantization shown above is highly simplified.&#x27;);</span><br><span class="line">disp(&#x27;A proper implementation requires using H.264 standard tables for MF and f based on QP.&#x27;);</span><br><span class="line">disp(&#x27;The core integer transform part Y = Cf * E_B2 * Cf&#x27;&#x27; is correct.&#x27;);</span><br><span class="line">disp(&#x27;For accurate quantization, refer to H.264 standard section 7.4.5.&#x27;);</span><br></pre></td></tr></table></figure>
<p>  <strong>逐步计算：</strong></p>
<ol>
<li>原始残差块 EB2​</li>
<li>计算 Temp&#x3D;EB2​⋅CfT​</li>
<li>计算 YB2​&#x3D;Cf​⋅Temp (核心变换结果)</li>
<li>对 YB2​ 的每个系数，应用H.264量化公式（涉及QP、MF、移位等）。</li>
</ol>
</li>
</ul>
<p><strong>4.4 Zigzag形扫描与熵编码，根据H.264的熵编码顺序，给出逐步熵编码的产生的码流，给出该4*4块B2最终的的码流：（可能用到的表格为H.264标准文档中Table 9.5 ~9.10）</strong></p>
<ul>
<li><p><strong>4x4 Zigzag扫描：</strong> H.264对4x4块的扫描通常也是Zigzag，但根据预测模式（如帧内4x4, 帧间等）可以有不同的扫描顺序。对于帧间残差，通常是标准的Zigzag。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  1  4  5</span><br><span class="line">2  3  6  7</span><br><span class="line">8  9 12 13</span><br><span class="line">10 11 14 15</span><br></pre></td></tr></table></figure>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% 4x4 Zigzag scan order</span><br><span class="line">zigzag_order_4x4 = [</span><br><span class="line">     0  1  4  5</span><br><span class="line">     2  3  6  7</span><br><span class="line">     8  9 12 13</span><br><span class="line">    10 11 14 15</span><br><span class="line">] + 1; % MATLAB 1-indexed</span><br><span class="line"></span><br><span class="line">B2_quant_zigzag = zeros(1, 16);</span><br><span class="line">temp_B2_quant = E_B2_quantized&#x27;; % Transpose for column-major scan</span><br><span class="line">for i = 1:16</span><br><span class="line">    B2_quant_zigzag(i) = temp_B2_quant(zigzag_order_4x4(i));</span><br><span class="line">end</span><br><span class="line">disp(&#x27;4.4.1 Zigzag scanned quantized coefficients for B2 residual:&#x27;);</span><br><span class="line">disp(B2_quant_zigzag);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>熵编码 (CAVLC - Context-Adaptive Variable Length Coding):</strong> H.264对残差系数的熵编码（主要是CAVLC或CABAC）非常复杂。CAVLC是 baseline profile 的标准。 CAVLC编码一个块的非零系数的过程：</p>
<ol>
<li><p><strong>编码 <code>coeff_token</code>:</strong></p>
<ul>
<li>取决于 <code>TotalCoeffs</code> (块中非零系数的个数) 和 <code>TrailingOnes</code> (尾随的 +&#x2F;-1 的个数，最多3个)。</li>
<li><code>coeff_token</code> 从特定的VLC表 (Table 9-5, Table 9-6 in H.264) 中查找，基于 <code>TotalCoeffs</code> 和 <code>TrailingOnes</code>。上下文模型也可能影响表的选择 (e.g., nC: a measure of previously coded non-zero coefficients in neighboring blocks).</li>
</ul>
</li>
<li><p><strong>编码 <code>TrailingOnes</code> 的符号:</strong> 每个 <code>TrailingOne</code> 的符号用1比特表示 (0 for +, 1 for -)。</p>
</li>
<li><p><strong>编码剩下非零系数的 <code>level</code>:</strong></p>
<ul>
<li>从后往前（不包括 <code>TrailingOnes</code>）编码每个非零系数的 <code>level</code> (幅值)。</li>
<li>使用 Golomb-Rice codes 或 Exp-Golomb codes (VLC tables)。</li>
</ul>
</li>
<li><p><strong>编码 <code>TotalZeros</code>:</strong></p>
<ul>
<li>编码在最后一个非零系数之前的所有0的总数 (<code>TotalZeros</code>)。</li>
<li>使用VLC表 (Table 9-7)，基于 <code>TotalCoeffs</code>。</li>
</ul>
</li>
<li><p><strong>编码每个非零系数前的 <code>run_before</code> (0的游程):</strong></p>
<ul>
<li>从后往前，为每个非零系数（不包括最后一个）编码其前面有多少个0 (<code>run_before</code>)。</li>
<li>使用VLC表 (Table 9-8, 9-9, 9-10)，取决于 <code>zerosLeft</code> (尚未编码的0的个数)。</li>
<li>如果所有剩余的0都在第一个非零系数之前，则不需要再编码 <code>run_before</code>。</li>
</ul>
</li>
</ol>
<p>  <strong>逐步熵编码的码流 (CAVLC 概念性示例):</strong> 假设 <code>B2_quant_zigzag = [3, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code></p>
<ol>
<li><code>TotalCoeffs = 3</code></li>
<li><code>TrailingOnes</code>:<ul>
<li><code>1</code> is a trailing one.</li>
<li><code>-1</code> is a trailing one.</li>
<li><code>3</code> is not. So, <code>TrailingOnes = 2</code>.</li>
</ul>
</li>
<li><strong><code>coeff_token</code>:</strong> 查找Table 9-5 (假设nC &lt; 2) for <code>TotalCoeffs=3</code>, <code>TrailingOnes=2</code>. 假设码字是 <code>&#39;0000110&#39;</code></li>
<li><strong>Signs of TrailingOnes:</strong><ul>
<li>For <code>1</code>: sign is <code>+</code> (code <code>0</code>)</li>
<li>For <code>-1</code>: sign is <code>-</code> (code <code>1</code>) TrailingOnes signs bitstream: <code>&#39;01&#39;</code></li>
</ul>
</li>
<li><strong>Levels of remaining coeffs (scan reverse, skip TrailingOnes):</strong><ul>
<li>Remaining coeff is <code>3</code>.</li>
<li>Encode <code>level</code> &#x3D; <code>3</code>. (Using Exp-Golomb or similar, e.g., <code>00100</code> for <code>3</code> if <code>level_prefix</code> and <code>level_suffix</code> rules are applied). Let’s say <code>level_code_for_3 = &#39;00111&#39;</code> (this is an example, actual code depends on specific Exp-Golomb parameters&#x2F;tables used by CAVLC for levels).</li>
</ul>
</li>
<li><strong><code>TotalZeros</code>:</strong><ul>
<li>Last non-zero coeff is <code>1</code> (at index 3 in zigzag). Before it, there is one <code>0</code> (at index 1).</li>
<li>So <code>TotalZeros = 1</code>.</li>
<li>Lookup Table 9-7 for <code>TotalCoeffs=3</code>, <code>TotalZeros=1</code>. Assume code is <code>&#39;11&#39;</code>.</li>
</ul>
</li>
<li><strong><code>run_before</code> for each coeff (scan reverse, stop before last):</strong><ul>
<li>Coeff <code>-1</code> (at index 2): <code>run_before</code> (zeros before it since previous non-zero) &#x3D; <code>1</code> (the zero at index 1). <code>zerosLeft</code> is initially <code>TotalZeros = 1</code>. Lookup Table (e.g., 9-10) for <code>run_before=1</code> given <code>zerosLeft=1</code>. Assume code is <code>&#39;1&#39;</code>. <code>zerosLeft</code> becomes 0.</li>
<li>Coeff <code>3</code> (at index 0): This is the first non-zero coeff to be considered in this step (after trailing ones). No more runs to code if <code>zerosLeft</code> is 0 or it’s the first significant coeff. (The logic for <code>run_before</code> is intricate; it’s about runs of zeros <em>between</em> the non-zero AC coefficients being coded in this phase).</li>
</ul>
</li>
</ol>
<p>  <strong>最终码流 (B2_final_bitstream_CAVLC):</strong> <code>&#39;0000110&#39; (coeff_token) + &#39;01&#39; (signs) + &#39;00111&#39; (level for 3) + &#39;11&#39; (TotalZeros) + &#39;1&#39; (run_before for -1)</code> <code>= &#39;00001100100111111&#39;</code></p>
<p>  <strong>MATLAB实现提示：</strong> CAVLC的完整实现非常复杂，需要仔细处理上下文、查多个VLC表、以及管理系数的扫描顺序。</p>
<p>  Matlab</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;4.4.2 H.264 Entropy Coding (CAVLC):&#x27;);</span><br><span class="line">disp(&#x27;CAVLC is complex. The following is a conceptual outline:&#x27;);</span><br><span class="line">disp(&#x27;1. Calculate TotalCoeffs and TrailingOnes from B2_quant_zigzag.&#x27;);</span><br><span class="line">disp(&#x27;2. Encode coeff_token (using Table 9-5/9-6 based on nC, TotalCoeffs, TrailingOnes).&#x27;);</span><br><span class="line">%   [coeff_token_bits] = get_coeff_token_cavlc(TotalCoeffs, TrailingOnes, nC_value);</span><br><span class="line">disp(&#x27;3. Encode signs of TrailingOnes (1 bit each).&#x27;);</span><br><span class="line">%   [trailing_ones_sign_bits] = get_trailing_ones_signs(B2_quant_zigzag, TrailingOnes);</span><br><span class="line">disp(&#x27;4. Encode levels of remaining non-zero coefficients (Exp-Golomb).&#x27;);</span><br><span class="line">%   [levels_bits] = encode_levels_cavlc(B2_quant_zigzag, TotalCoeffs, TrailingOnes);</span><br><span class="line">disp(&#x27;5. Encode TotalZeros (zeros before last non-zero coeff, Table 9-7).&#x27;);</span><br><span class="line">%   [total_zeros_bits] = encode_total_zeros_cavlc(B2_quant_zigzag, TotalCoeffs);</span><br><span class="line">disp(&#x27;6. Encode run_before for zeros preceding each non-zero coeff (Tables 9-8/9-9/9-10).&#x27;);</span><br><span class="line">%   [runs_bits] = encode_runs_cavlc(B2_quant_zigzag, TotalCoeffs, TotalZeros);</span><br><span class="line">% block_B2_final_stream = [coeff_token_bits, trailing_ones_sign_bits, levels_bits, total_zeros_bits, runs_bits];</span><br><span class="line">disp(&#x27;The final bitstream for B2 is the concatenation of these parts.&#x27;);</span><br><span class="line">disp(&#x27;Actual bit values require implementing the lookup for H.264 Tables 9-5 to 9-10.&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>这是一个相当全面的大作业。在MATLAB中实现这些，特别是JPEG的完整熵编码和H.264的CAVLC，需要花费大量时间和精力进行调试。建议你分模块实现和测试，并仔细阅读相关的标准文档。</p>
<p>祝你顺利完成作业！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/" rel="tag"># 视频编码</a>
              <a href="/tags/MATLAB/" rel="tag"># MATLAB</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/01/%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" rel="prev" title="调研报告">
      <i class="fa fa-chevron-left"></i> 调研报告
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/01/%E5%A4%A7%E8%8B%B1%E8%AF%BE%E6%96%87/" rel="next" title="大英课文">
      大英课文 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="St_w"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">St_w</p>
  <div class="site-description" itemprop="description">老大，欢迎回来喵~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Fri May 30 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">St_w</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共74.2k字</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  











<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

    </div>
</body>
</html>
